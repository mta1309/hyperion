/*
    herctest.c, run test cases and analyze results

    Copyright 2018 Stephen R. Orso.

    Distributed under the Boost Software License, Version 1.0.  See
    accompanying file BOOST_LICENSE_1_0.txt or a copy at
    http://www.boost.org/LICENSE_1_0.txt)

    The getopt_long() function and the declarations, definitions, and
    macros needed to compile and use getopt_long on Windows are
    Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>, used
    by permission, and Copyright (c) 2000 The NetBSD Foundation, Inc.,
    used in accordance with the terms of the license agreement. See the
    following for the original source and the complete text of the
    license agreement.

    https://github.com/freebsd/freebsd/blob/master/include/getopt.h
    https://github.com/freebsd/freebsd/blob/master/lib/libc/stdlib/getopt.c

    The permission notice and license agreement are reproduced in full
    just before the definition of the function getopt_long(), which is
    located at the end of this compilation unit.

    Code needed to compile under Windows is derived from BSD getopt.h,
    which is Copyright (c) 1989, 1993 The Regents of the University of
    California, and used under the terms of its BSD 3-clause license
    agreement.  See the following for the original source and the
    complete text of the license agreement.

    https://github.com/freebsd/freebsd/blob/master/include/glob.h

*/


/* ********************************************************************

    herctest.c, run test cases and analyze results

Function/Operation -
 *  Using command line options and defaults, assemble a suite of test
    scripts, run Hercules using those scripts, and analyze the results.
    Summary results are written to an output file that lists each test
    case that was run and the number of tests in each case that passed
    and failed.
 *  A single test script may include multiple test cases, and each test
    case may include multiple tests.
 *  Hercules is executed to run all test scripts, with output captured
    to a log file for analysis by the Hercules REXX script redtest.rexx.
    Platfrom-specific techniques are used to execute Hercules and
    redtest.rexx as child processes.
 *  Errors in command line options or the absence of requested or
    required files cancel the execution of Hercules and redtest.rexx

Entry Points -
 *  One, main(), invoked using the standard c program interface (argc
    and argv).
 *  All functions and global data are declared static and are not
    exposed to the outside world.  This program declares no Application
    Programming Interface beyond main( int argc, char ** argv ).
 *  The command line option -? displays short help, and --help displays
    more detailed help.

Input -
 *  Command line parameters that identify:
    - the test scripts to be run,
    - the directory containing the test scripts and the redtest.rexx
      result analysis tool,
    - any Hercules loadable modules to be loaded,
    - the location of the Hercules executable,
    - the test script repeat count,
    - the timeout adjustment factor, and
    - the file name of the work files used.
    Refer to the short and long help for specifics of the command line
    parameters.
 *  One or more test scripts containing test cases and the expected
    results from each of those test cases.  Test scripts default to
    an extension of ".tst" although other extensions may be specified
    in command line options.
 *  If run from the tests subdirectory of a Hercules build directory,
    no command line parameters are required, and if none are provided,
    all test scripts in that directory will be run.

Output -
 *  This program creates one file, default name allTests.testin, that is
    used as a Hercules Run Commands (RC) file.  This file contains a
    set of Herules `script` commands that run the required test scripts.
 *  This program executes Hercules with console output redirected to
    a file, default name alltests.log.  This file contains output
    generated by Hercules as a result of the test scripts. The log file
    analysis program redtest.rexx uses this file as input.
 *  This program executes redtest.rexx, a REXX script that analyzes
    the Hercules output generated by the test scripts and creates a
    file allTests.txt that summarizes results one line per test case.
 *  The file name allTests may be changed as desired using the -w
    command line option.  The extensions .testin, .out, and .txt may
    not be changed by command line option.
 *  Return codes document at a summary level success or failure of the
    entire process.
 *  Error messages are issued on stderr if there are errors in command
    line parameters, required files are missing, or child processes
    (Hercules, redtest.rexx) fail.
 *  If a command line option error is detected, short help is displayed
    at exit.

External References -
 *  The core logic of this program uses POSIX functions that have been
    defined since ca. 2001.  Testing suggests that this program compiles
    and executes correctly on Windows 7 and newer, macOS High Sierra,
    assorted recent Linux distributions, and FreeBSD 11.1.
 *  When compiled on Windows, wrapper functions are included for
    selected POSIX functions that have not been implemented in Windows.
 *  On UNIX-like systems including OS X/macOS, FreeBSD, and Linux,
    Hercules and redtest.rexx are spawned as child processes using
    fork/execvp.  Functions freopen and dup2 are used to redirect
    stdin, stdout, and stderr as needed.
 *  On Windows systems, CreateProcess is used to spawn Hercules and
    redtest.rexx.  CreateFile is used to to redirect stdin, stdout, and
    stderr as needed.

Exits -
 *  To the host system with return code zero when all functions have
    completed successfully.
 *  To the host system with a non-zero return code when a) command line
    parameters failed validation, b) required modules are missing, or
    c) child processes Hercules or redtest.rexx failed.

Return Codes -
  0   - All tasks completed successfully, and all tests passed.
  1-239 - All tasks completed successfully, but one or more tests
        failed.
  240 - More than 239 tests failed.  The exact count is unavailable.
  241 - Error in command line options or arguments, including missing
        files or directories specified on the command line.
  242 - Error setting defaults for unspecified command line options,
        including missing default files or directories.
  243 - Specified or default test scripts missing (absolute path used
        as argument to -f command line option) or missing from the test
        scripts directory (relative path).
  244 - Loadable module not present in modpath directory.
  245 - Failed to create the allTests.testin RC file for Hercules
        execution.
  246 - Failed to build the argument list for Hercules execution.
  247 - Failed to spawn the Hercules child process.
  248 - Failed to build the argument list for redtest.rexx execution.
  249 - Failed to spawn the child process for redtes.rexx.

Portability -
 *  This program does not use a configure step and does not include
    config.h from the Hercueles build (CMake or autotools).  Four
    strategies are used to enable platform-independent compilation and
    execution:
    -   Core logic is written using POSIX-defined functions and does not
        have platform-specific tests or sensitivities.
    -   Where Windows does not have a POSIX interface but does have an
        interface that can be co-opted to produce a matching result, a
        wrapper function prefixed "win_" is written and a preprocessor
        macro defines either the native POSIX function or the Windows
        wrapper function.  See GET_REALPATH, GLOB, and GLOBFREE for
        examples of this.
    -   Where Windows and UNIX-like systems have approaches too
        different to reconcile using a wrapper function, a herctest
        function is versioned based on platform.  See get_exepath(),
        has_extension(), and run_child_process() for examples of this
        approach.
    -   Where Windows has no equivalent function, permissively-licensed
        source from FreeBSD is included in this module modified as
        needed to operate as needed in Windows.  See getopt() and
        getopt_long() for the example of this.
 *  Selected platform differences, for example the possibility of a
    GNU libtool executable directory '.libs' or the valid characters
    for globbing, are indicated by #defines of difference-specific
    macros rather than testing the platform name in main line code.

Notes -
 *  This program has been demonstrated to fail on Debian 5.4 (Lenny,
    14-Feb-2009) because of a floating point issue that affects the
    validation of the -t parameter.  This is under investigation, but
    not as an urgent issue.

*/


/* ********************************************************************
    Standard includes, as required by the host system.
*/
#if defined(_WIN32)             /* includes required for Windows        */
#  include <windows.h>          /* required Windows header              */
#  include <sdkddkver.h>        /* for Windows version testing, needed  */
                                /* ...to deal with the deprecation of   */
                                /* ...the char * _pgmptr extern.  see   */
                                /* ...Get_exepath() for details.        */
#include <io.h>                 /* required for _access()               */
#endif
                                /* includes required on all systems     */
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>              /* required for errno constants         */
#include <stdarg.h>             /* for va_start/va_arg/va_end, used in  */
                                /* ...concat_strings()                  */
#include <string.h>
#include <sys/stat.h>           /* for stat() function                  */
#include <time.h>               /* for timestamp conversion functions,  */
                                /* ...used to include timestamps in the */
                                /* ...allTests.testin RC file.          */

#if !defined(_WIN32)            /* includes needed on UNIX-like systems */
                                /* ...Which includes OS X/macOS         */
#  include <unistd.h>
#  include <errno.h>            /* errno externs and macros             */
#  include <getopt.h>           /* system-provided getopt_long()        */
#  include <libgen.h>           /* basename(), dirname() functions      */
#  include <dirent.h>           /* scandir functions                    */
#  include <glob.h>             /* file name globbing                   */
#  include <sys/utsname.h>      /* uname(), to set platform=            */
#  include <sys/wait.h>         /* wait(), await hercules/redtest exec  */
#  if defined(__APPLE__)
#    include <mach-o/dyld.h>    /* for _NSGetExecutablePath             */
#  endif
#endif


/* ********************************************************************
    Define macros for file name lengths.  Function concat_strings()
    uses MAX_PATH as a sanity check on the result length of the strings
    being concatenated.
*/
#ifndef     MAX_PATH
  #ifdef    PATH_MAX
    #define MAX_PATH          PATH_MAX
  #else
    #define MAX_PATH          4096
  #endif
#endif


/* ********************************************************************
    Define the following to enable inclusion of the dump_globals()
    function.  It may be called from anywhere for diagnostic purposes.
*/
//  #define DUMP_GLOBALS


/* ********************************************************************
    Define defaults for various strings and constants
*/
#define HERC_RC_EXT      ".testin"  /* hercules rc file extension       */
#define HERC_LOG_EXT     ".out"     /* hercules console file extension  */
#define REDTEST_LOG_EXT  ".txt"     /* test results file extension      */
#define TESTS_SUBDIR     "tests"    /* subdirectory containing scripts  */
#define FNAME_WORKFILES  "allTests" /* default filename for workfiles   */

#define CONCAT_RES_LEN     128      /* Initial alloc for concatenation  */
#define CONCAT_MAX_ARGS    50       /* max strings to concatenate       */
#define CONCAT_TOO_LONG  "**Too Long**"  /* diagnostic for overmax      */

#define CMDLINE_ALLOC      256      /* Initial/additional alloc for     */
                                    /* Windows cmdline including '\0'   */
                                    /* for CreateProcess function       */

#define WIN_GLOB_PATH_ALLOC 128     /* Initial/add'l alloc for string   */
                                    /* array when globbing on Windows   */

#define TEST_SCRIPT_EXT  "tst"      /* test script extension (-e)       */

#define PTRSIZE_NAME    "ptrsize"   /* var part of "-v ptrsize=" opt    */
#define CONFIG_H_NAME   "config.h"  /* file name of Hecules config file */
#define PTRSIZE_SOURCE  "SIZEOF_SIZE_T"   /* config #define for ptrsize */
#define PLATFORM_NAME   "platform"  /* var part of "-v platform=" opt   */
#define QUIET_NAME      "quiet"     /* test for -v quiet                */
#define REDTEST_REXX    "redtest.rexx"  /* name of reduction script     */
                                    /* POSIX Portable File Name         */
                                    /* character set.                   */
#define POSIX_FN_CHARS  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-"


/* ********************************************************************
    The following macros define the initial allocations for the arrays
    that hold the sundry strings used by this program.  The array
    structures are defined with zero array elements, and the routines
    that manipulate the structures will increase the array allocation by
    the amounts below when more room is needed to add a string.
*/
#define PROCARG_COUNT      64       /* Initial Hercules argument count  */
#define LOADMOD_COUNT      64       /* Initial load module name alloc   */
#define TEST_SCRIPT_COUNT  64       /* Initial test script name alloc   */
#define VARVAL_COUNT       64       /* Initial var=val pair alloc       */


/* ********************************************************************
    Sundry platform-specific strings and constants
*/
#if defined(_WIN32)                 /* **** Windows systems ****        */
#  define LOADMOD_SUFFIX ".dll"
#  define HERCULES_EXE   "hercules.exe"
#  define PATH_SEPC      '\\'
#  define PATH_SEPS      "\\"
#  define WILDCARD_DIR   "\\*"
#  define GLOBBING_CHARS "*?"
#  define PATH_SEPS_AMBI "\\/"      /* either path separator            */
#  define PLATFORM_VALUE "Windows"
#  define REXX_EXE       "cmd.exe"
#  define REXX_EXE_FLAGS "/c"       /* flags for REXX executable        */
#  define ENCAPSULATE_REXX_REDTEST  /* encapsulate in dbl quotes        */
#  if defined(WINVER) && WINVER >= _WIN32_WINNT_WIN7
#    define USE_GET_PGMPTR          /* Win 7 or better, use _get_pgmptr */
                                    /* instead of deprecated _pgmptr    */
#  endif
#else                               /* **** non-Windows systems ****    */
#  define LOADMOD_SUFFIX ".so"
#  define HERCULES_EXE   "hercules"
#  define PATH_SEPC      '/'
#  define PATH_SEPS      "/"
#  define WILDCARD_DIR   "/*"
#  define GLOBBING_CHARS "*?["
#  define REXX_EXE       "rexx"
#  undef  PATH_SEPS_AMBI            /* only one kind of path separator  */
#  undef  PLATFORM_VALUE            /* determined at runtime            */
#  undef  REXX_EXE_FLAGS            /* no REXX flags for UNIX-like CLI  */
#  undef  ENCAPSULATE_REXX_REDTEST  /* do not encapsulate in dbl quotes */
#  if !defined(__APPLE__)
#    define LIBTOOL_SUBDIR ".libs"  /* libtool is UNIX-like only        */
#  endif
#endif


/* ********************************************************************
    Define access() function based on host system.  The Windows 
    _access() function is pretty much identical to the POSIX.1-2001
    access() function, but they have slightly different names.  Windows
    also fails to define helpful macros for the access type.
*/
#if defined(_WIN32)
#  define W_OK 0x02
#  define R_OK 0x04
#  define ACCESS( path, acc_type ) _access( path, acc_type )
#else
#  define ACCESS( path, acc_type ) access( path, acc_type )
#endif


/* ********************************************************************
    Define absolute path function based on host system.  The native
    realpath() function available on UNIX-like systems is sufficient,
    and it's easy enough to code an equivalent Windows function.
*/
#if defined(_WIN32)
#  define GET_REALPATH( relpath ) win_realpath( relpath )
#else
#  define GET_REALPATH( relpath ) realpath( relpath, NULL )
#endif


/* ********************************************************************
    Define glob() function based on host system.  The native glob()
    function available on UNIX-like systems is sufficient, so there is
    no need for a wrapper.  A Windows function that implements enough
    of glob() for this program is also easy enough to code.
*/
#if defined(_WIN32)
#  define GLOB( pattern, flags, errfunc, result ) \
                win_glob( pattern, flags, errfunc, result)
#  define GLOBFREE( result ) win_globfree( result )
#else
#  define GLOB( pattern, flags, errfunc, result ) \
                glob( pattern, flags, errfunc, result)
#  define GLOBFREE( result ) globfree( result )
#endif


/* ********************************************************************
    typedef/struct definition for an array of strings.  This program
    uses four arrays of strings that are allocated and expanded as
    needed: load module names, test script names, variable=value pairs,
    and the argv array passed to fork/exec.  Because each has the same
    structure, we can do a typedef and use the same routines to manage
    each.
*/
struct stringctl_s
{
    char ** string;         /* array of strings                         */
    int     alloc;          /* current allocaction of string elements   */
    int     index;          /* index of last used string, -1 if empty   */
    int     next_alloc;     /* number of element to create or add       */
                            /* when array needs to be expanded          */
    char *  desc;           /* text description of array contents       */
};
typedef struct stringctl_s stringctl_t;


/* ********************************************************************
    Forward declarations for all functions defined in this compilation
    unit.
*/
/* Main line functions                                                  */
int main(                   /* main line processing                     */
        int,                /* command line argument count              */
        char ** );          /* c-style arguments                        */

static int process_args(    /* process command line arguments           */
        int,                /* ..count of arguments                     */
        char ** );          /* ..array of argument pointers             */
                            /* rc = nr. of errors detected              */

static int set_defaults(    /* set defaults for unspecified options     */
        char ** );          /* argv array, needed for exe path          */

static int validate_arg_scripts_array();    /* validate test scripts    */
                            /* rc = nr of non-existant test scripts     */

static int validate_loadables();   /* validate load modules in modpath  */
                            /* rc = nr of non-existant loadable modules */

static int build_test_script_rc_file();     /* create Hercules RC file  */
                            /* no return codes (yet).                   */

static int build_hercules_arglist();    /* build Hercules arg list      */
                            /* no return codes                          */

static int build_redtest_arglist();     /* build redtest.rexx arg list  */
                            /* no return codes                          */

static int run_child_process(   /* run child procs, wait for completion */
        const char *,       /* descriptive name of child process        */
        const char *,       /* name of stdout/stderr redir file         */
        int,                /* if 1, enclose args in double quotes      */
        int *               /* location to store child process rc       */
        );                  /* ...used only by Windows version          */
                            /* rc = 0 means normal process completion   */

/* Utility functions                                                    */
static void dump_globals(); /* dump global vars to stdout for debug     */

static int addto_string_array(  /* Add elementn to string array         */
        stringctl_t *,      /* ..array to receive new element           */
        char * );           /* ..malloc'd string to be added            */
                            /*  rc always zero (0) (for now)            */

static char * concat_strings(   /* Concatenate strings                  */
        char *,             /* ..first string of list of strings        */
        ...);               /* ..more strings, NULL at end of list      */
                            /* rc = pointer to malloc'd result string   */

/* argument validation and global table update routines                 */
static void add_args_script(    /* Add name to test script arg array    */
         char *,            /* ..file name to be added                  */
         const char * );    /* ..name of option being processed         */

static void add_load_module(    /* Add module to loadable module array  */
         char *,            /* ..name of loadable module to be added    */
         const char * );    /* ..name of option being processed         */

static void add_test_script(    /* Add file name to test script array   */
         char *,            /* ..file name of test script to be added   */
         const char * );    /* ..name of option being processed         */

static int add_varval_pair(        /* Add a var=val pair to var=val array      */
        char *,             /* ..variable=value pair to be added        */
        const char *,       /* ..desc. of option being processed        */
        int );              /* ..if 1, allow setting of platform        */
                            /* rc -1 if invalid var=val pair, else zero */

static int check_arg_dir(   /* check a directory argument, set pointer  */
                            /* ..used for -d, -p, -w directories        */
        char *,             /* ..directory to be validated              */
        char **,            /* ..pointer to directory pointer           */
        const char * );     /* ..name of option being processed         */
                            /* rc = 0 if dir valid, 1 otherwise         */

static int check_arg_hercexe(   /* check hercules exe path, set ptr     */
        char *,             /* ..executabel path to be validated        */
        char **,            /* ..pointer to executable path pointer     */
        const char * );     /* ..name of option being processed         */
                            /* rc = 0 if path valid, 1 otherwise        */

static char * get_dirname(  /* get directory portion of path name       */
        const char * );     /* path name to have lasts bit excised      */
                            /* NULL returned if unable                  */

static int get_exepath(     /* get full path of current executable      */
        const char * );     /* ..argv[ 0 ], used for UNX-like systems   */
                            /* NULL returned if unable to determine     */

static int get_ptrsize( );  /* scan config.h to determine ptrsize=,     */
                            /* add to varval array.                     */
                            /* rc = 0 if added, 1 otherwise             */

static int has_extension(   /* return true if filename has ext.         */
        char * );           /* ..path name to be tested for extension   */
                            /* rc = 1 path has extension, 0 otherwise   */

static void long_help();    /* display long help text --help            */

static void short_help();   /* display short help                       */


/* ******************************************************************** */
#if defined(_WIN32) /* ***** declarations etc for Windows wrappers **** */

/* ********************************************************************
    Declarations and macro definitions needed to compile getopt_long()
    under Windows.  This code is taken from FreeBSD source files
    getopt_long.c and getopt.h and is used under the terms of the
    license granted by the authors.  The copyright notice for this
    code is in the beginning of this compilation unit and the complete
    copyright and license terms are reproduced below.

    Forward function declaration and structure definitions for Windows
    compilation of getopt_long.
*/
/* globals from BSD getopt.c                                            */
static int	   opterr = 1;		/* if error message should be printed   */
static int	   optind = 1;	    /* index into parent argv vector        */
static int	   optopt = '?';    /* character checked for validity       */
static int	   optreset;	    /* reset getopt                         */
static char * optarg;		    /* argument associated with option      */

/* struct options from getopt.h                                         */
struct option {
	const char *name;   /* name of long option                          */
	int has_arg;        /* whether option takes an argument, one of     */
                /* no_argument, required_argument, optional_argument    */
	int *flag;          /* if !NULL, set *flag to val when option found */
	int val;            /* if flag not NULL, value to set *flag to;     */
                        /* ...else return value                         */
};

/* Forward declaration of getopt_long().                                */
static int getopt_long( int ,   /* count of arguments on command line   */
            char * const *, /* Array of pointers to argument strings    */
            const char *,   /* string of allowed short options          */
            const struct option *, /* structure of allowed long options */
            int * );        /* pointer to found long option or -1       */

/* disable error functions from getopt                                  */
#define warnx(...)

/* other defines from BSD getopt.h */
#define no_argument        0
#define required_argument  1
#define optional_argument  2
/* ************ end of content subject to getopt copyright ************ */

/* ********************************************************************
    Definitions adapted from glob.h and needed to compile this program
    under Windows.  This code is adapted from FreeBSD source file
    glob.h and is adapted under the terms of the copyright holder. The
    copyright notice for this code is in the beginning of this
    compilation unit.
*/

typedef struct {
	size_t gl_pathc;    /* Count of total paths so far.                 */
	size_t gl_offs;	    /* Reserved at beginning of gl_pathv (not impl.)*/
	char **gl_pathv;    /* List of paths matching pattern.              */
} glob_t;
/* * end of content derived from material subject to getopt copyright * */
/* ******************************************************************** */

#endif      /* ***** end of declarations etc for Windows wrappers ***** */
/* ******************************************************************** */


#if defined(_WIN32)
/* Windows values for stat fst.mode executable.  Windows does not have  */
/* group and other executable flags on the base file system, we shall   */
/* not get into access tokens for a command line argument test, and     */
/* Windows has deprecated S_IXUSR in favor of S_IEXEC. So we code       */
/* premeptively for its disappearance.                                  */
#  if !defined(S_IXUSR)
#    define S_IXUSR S_IEXEC
#  endif
#define S_IXGRP 0
#define S_IXOTH 0

/* Windows values for stat fst.mode read. See above...                  */
#define S_IRGRP 0
#define S_IROTH 0

/* Macros for Windows tests of stat structure from stat() function.     */
/* Windows fails to define them for us.                                 */
#define	S_ISDIR(st_mode) (((st_mode) & _S_IFMT) == _S_IFDIR)    /* directory    */
#define	S_ISREG(st_mode) (((st_mode) & _S_IFMT) == _S_IFREG)	/* regular file */

/* forward declarations for Windows wrappers to enable portability      */
static char * win_realpath( /* get absolute path of named file          */
        const char * );     /* argv[ 0 ], used for UNX-like             */
                            /* NULL returned if invalid/nonexist. file  */

static int win_glob(        /* limited function glob() for Windows      */
        const  char *,      /* pattern to be matched on a glob call     */
        int,                /* processing flags (not implemented)       */
        int (*)(const char *, int), /* error function (not impl.)       */
        glob_t * );         /* glob_t struct with returned paths        */
                            /* rc=0 if all OK                           */

static void win_globfree(   /* free storage in glob_t structure         */
        glob_t * );         /* glob_t structure to be free'd            */
                            /* no return value                          */

#endif
/* ******************************************************************** */


/* ********************************************************************
    Global variable declarations.  These are limited to strings and
    values that will be used to generate the Hercules command line
*/

/* directories and absolute paths                                       */
static char *  dir_test_scripts = NULL; /* test scripts directory       */
static char *  dir_modpath = NULL;  /* loadable module directory        */
static char *  exe_hercules = NULL; /* Hercules executable full path    */
static char *  dir_hercules = NULL; /* directory containing the above   */
static char *  rexx_redtest = NULL; /* redtest.rexx script full path    */
static char *  dir_herctest = NULL; /* executable dir for this program  */
static char *  name_herctest = NULL;    /* name of this executable      */

/* filename for herctest work files, default AllTests                   */
static char *  fname_workfiles = NULL;

/* workfile file names with extensions, all relative to CWD             */
static char * herc_rc_file; /* rc file name                             */
static char * herc_log;     /* hercules exec log                        */
static char * redtest_log;  /* redtest exec log                         */


/* String arrays for arguments to -f, load modules, test scripts,       */
/* var=value pairs, and  arguments to be passed to Hercules during      */
/* fork/exec.  The initialization values NULL, 0, -1 and  the array     */
/* description indicate an array with no elements and no room for more  */
/* elements; this triggers an initial allocation on first add.          */
/* All but the procargs array are arrays of pointers to malloc'd        */
/* strings, and free'ing the array means first free'ing each string     */
/* included in the array.                                               */

static stringctl_t args_scripts = { NULL, 0, -1, TEST_SCRIPT_COUNT, "-f argument"   };
static stringctl_t loadmod      = { NULL, 0, -1, LOADMOD_COUNT,     "load module"   };
static stringctl_t test_scripts = { NULL, 0, -1, TEST_SCRIPT_COUNT, "test script"   };
static stringctl_t varval       = { NULL, 0, -1, VARVAL_COUNT,      "var=val pair"  };

/* The procargs array will contain the c-style parameter list used to   */
/* invoke Hercules and redtest.rexx on UNIX-like systems, and from      */
/* which the Windows command line used to start Hercules is built.  All */
/* strings pointed to by this array are either constants or are copies  */
/* of pointers from the above arrays.  This array can be free'd just by */
/* free'ing the array itself.  The strings will be free'd as needed     */
/* when the above arrays are free'd.                                    */

static stringctl_t procargs     = { NULL, 0, -1, PROCARG_COUNT,     "child args" };

static char *  test_script_ext = NULL; /* default test script extension */
                            /* ...*WITHOUT* the period                  */

/* other flags to hercules or redtest.rexx                              */
static int     rep_count = 1;   /* test script repetition count         */

                                /* timeout adjustment factor            */
static float   timeout_factor = 1.0f;   /* test script t/o adj. factor  */
static float   timeout_limit = 14.3f;   /* maximum t/o adj. factor      */
static char    timeout_factor_s[ 10 ];  /* t/o factor in string form    */

static int     no_exit = 0;         /* 1 = omit "exit" at end of RC     */
static int     redtest_quiet = 0;   /* 1 = pass quiet to redtest        */

/* Global flags used by this program                                    */
static int     ptrsize_found = 0;   /* cmd included -v ptrsize if true  */



/* ********************************************************************
    Main function.

    Do the following:
    1. Edit and process the command line arguments, and build the global
       data structures needed to turn those arguments into Hercules and
       redtest.rexx command line arguments.
    2. For command line options not specified, establish default options
       consistent with help displays for this program.
    3. Ensure all files required to run Hercules to run
       the test scripts and and run redtest.rexx to analyze the results exist.
    4. Create an input run commands file (.rc) for Hercules and run
       Hercules with that command file.
    5. Run redtest.rexx to analyze the output log from Hercules.
*/
int main( int argc, char ** argv )
{
    int ec;                 /* error code returned by many functions    */
    int child_rc;           /* return code from child process           */
    int rc = 0;             /* return code from mainline                */
    int i;                  /* sundry loop control                      */

#if defined(DUMP_GLOBALS)

    char * msg;
    /* Dump the command line arguments                                  */
    msg = "Cmdline args:";
    for ( i = 0; i < argc; i++ )
    {
        fprintf( stdout, "%s %3d. %p -> \"%s\"\n", msg, i, argv[ i ], argv[ i ] );
        msg = "             ";
    }
    fprintf( stdout, "\n" );
#endif

    test_script_ext = strdup( TEST_SCRIPT_EXT );  /* default test       */
                            /* ...script extension *WITHOUT* period     */

                            /* get dir containing this executable       */
    ec = get_exepath( argv[ 0 ] );
    if ( ec )               /* able to determine executable path?       */
                            /* ..no, error message, continue            */
        fprintf( stderr, "Unable to determine executable path, rc=%d, for \"%s\"\n",
                ec, argv[ 0 ] );

    /* Calculate the maximum timeout expansion factor.  The following   */
    /* expression must match the #define for MAX_RUNTEST_FACTOR in      */
    /* Hercules hconsts.h                                               */
    timeout_limit = (float) (((4.0 * 1024.0 * 1024.0 * 1024.0) - 1.0)
                            / 1000000.0     /* (usecs)                  */
                            / 300 );        /* MAX_RUNTEST_DUR          */
    timeout_limit = ((float) ((int) (timeout_limit * 10 + 0.5))) / 10;

    /* Process command line options and arguments                       */
    if ( ( ec = process_args( argc, argv ) ) )
        rc = 241;

    /* Set defaults for unspecified opts                                */
    else if ( ( ec = set_defaults( argv ) ) )
        rc = 242;

    /* ensure test scripts exist                                        */
    else if ( ( ec = validate_arg_scripts_array() ) )
        rc = 243;

    /* ensure loadable modules exist                                    */
    else if ( ( ec = validate_loadables() ) )
        rc = 244;

    /* build the Hercules RC run commands file                          */
    else if ( ( ec = build_test_script_rc_file() ) )
        rc = 245;

    /* build the Hercules argument list                                 */
    else if ( ( ec = build_hercules_arglist() ) )
        rc = 246;

    /* Run Hercules                                                     */
    else if ( ( ec = run_child_process( "Hercules",
            herc_log, 1, &child_rc ) ) )
        rc = 247;

    /* build the redtest.rexx argument list                             */
    else if ( ( ec = build_redtest_arglist() ) )
        rc = 248;

    /* run redtest.rexx to analyze Hercules output.  If redtest.rexx    */
    /* spawns successfully, run_child_process will return zero, and     */
    /* we will use the return code from the child process as the        */
    /* herctest return code.                                            */
    else if ( ( ec = run_child_process( "Redtest.rexx",
            redtest_log, 0, &child_rc ) ) )
        rc = 249;

    /* No errors detected in herctest processing.  Use redtest.rexx     */
    /* return code as the herctest return code.                         */
    else
        rc = child_rc;

#if defined(DUMP_GLOBALS)
    dump_globals();
#endif

    /* free all array elements and the root arrays.  This is not        */
    /* strictly necessary because the next step is return to shell,     */
    /* which will free everything.  But if one is running a memory      */
    /* analysis tool such as Valgrind, free'ing everything really       */
    /* helps in understanding whether memory leaks are an issue.        */
    for ( i = 0; i <= varval.index; i++ )
        free( varval.string[ i ] );
    free( varval.string );
    varval.string = NULL;

    for ( i = 0; i <= loadmod.index; i++ )
        free( loadmod.string[ i ] );
    free( loadmod.string );
    loadmod.string = NULL;

    for ( i = 0; i <= args_scripts.index; i++ )
        free( args_scripts.string[ i ] );
    free( args_scripts.string );
    args_scripts.string = NULL;

    for ( i = 0; i <= test_scripts.index; i++ )
        free( test_scripts.string[ i ] );
    free( test_scripts.string );
    test_scripts.string = NULL;

    free( procargs.string );
    procargs.string = NULL;

    free( dir_test_scripts );
    free( dir_modpath );
    free( exe_hercules );
    free( rexx_redtest );
    free( dir_hercules );
    free( test_script_ext );
    free( fname_workfiles );
    free( dir_herctest );
    free( name_herctest );

    dir_test_scripts    = NULL;
    dir_modpath         = NULL;
    exe_hercules        = NULL;
    rexx_redtest        = NULL;
    dir_hercules        = NULL;
    test_script_ext     = NULL;
    fname_workfiles     = NULL;
    dir_herctest        = NULL;
    name_herctest       = NULL;

    free( herc_rc_file );
    free( herc_log );
    free( redtest_log );

    herc_rc_file        = NULL;
    herc_log            = NULL;
    redtest_log         = NULL;

    return rc;
}


/* ********************************************************************
    Function process_args

    Validate command line options and arguments and populate the global
    variables based on the options and arguments provided.  Default
    values are not processed here; defaults are set after all command
    line arguments have been processed.  The interactions between
    options, for example the test script directory and test script file
    names, cannot be addressed until after all options and arguments
    have been validated.
*/
int process_args( int argc, char * argv[] )
{
/*  short (single-dash) command line options                            */
    static const char * options_allowed = ":d:e:f:h:l:p:qr:t:v:w:x";

/*  long (single-dash) command line options.  All have short            */
/*  equivalents except --helplong.                                      */
    static const struct option longopts[] = {
	     { "testdir",	required_argument,	    NULL,   'd' },
	     { "testext",   required_argument,	    NULL,	'e' },
	     { "testname",  required_argument,	    NULL,   'f' },
	     { "hercdir",   required_argument,	    NULL,   'h' },
	     { "loadmod",   required_argument,	    NULL,   'l' },
	     { "modpath",   required_argument,	    NULL,   'p' },
	     { "quiet",     no_argument,	        NULL,   'q' },
	     { "testreps",  required_argument,	    NULL,   'r' },
	     { "timeout",   required_argument,	    NULL,   't' },
	     { "var",       required_argument,	    NULL,   'v' },
	     { "workdir",   required_argument,	    NULL,   'w' },
	     { "noexit",    no_argument,	        NULL,   'x' },
	     { "help",      no_argument,	        NULL,   2   },
	     { "helplong",  no_argument,	        NULL,   1   },
	     { NULL,	    0,			            NULL,	0   }
     };

    int opt;                    /* current short option being processed */
    int longopts_index = -1;    /* index of identified long option      */
    int display_help = 0;       /* was help requested, >0 == TRUE       */
    int arg_error_count = 0;    /* count of errors related to args      */
    int error_count = 0;        /* count of errors related to options   */
    char * msg;                 /* text of message to be issued         */
    char * repcount_arg_end;    /* pointer to end of valid part of rep  */
    char * timeout_arg_end;     /* pointer to end of valid part of t/o  */
    char * option_name;         /* string containing current option     */
    char long_option[ 12 ] =    /* base string for long option display  */
            {'-', '-' };        /* ..starts with "--"                   */
    char short_option[3] =      /* base string for short opt display    */
            { '-', '?', '\0' }; /* ..starts with "-"                    */

    /* flags for options that may have only one argument and may be     */
    /* specified only once.                                             */
    int have_testscript_dir  = 0;   /* -d/--testdir: test script dir    */
    int have_modpath_dir     = 0;   /* -p/--modpath: loadable mod'l dir */
    int have_fname_workfiles = 0;   /* -w/--workdir: working directory  */
    int have_hercexe_path    = 0;   /* -h/--hercdir: executable path    */
    int have_repcount        = 0;   /* -r/--testreps: test repeat count */
    int have_timeout         = 0;   /* -t/--timeout: t/o adjustment     */

    opterr = 0;   /* we will handle error messages    */

    while ( (opt = getopt_long( argc, argv, options_allowed, longopts, &longopts_index)) != -1 )
    {
        /* get a pointer to the option name (e.g., -v, --hercdir for    */
        /* use in diagnostic messages.                                  */
        if ( longopts_index >= 1 )  /* Valid long option coded?         */
        {                           /* ..yes, append it to "--"         */
            long_option[ 2 ] = '\0';    /* trunc. name to "--" and add  */
            strcat( long_option, longopts[ longopts_index ].name);
            option_name = long_option;
        }
        else if ( (char) opt == '?' )   /* invalid option coded?        */
            if ( (char) optopt == '\0' )    /* Invalid long ("--")?     */
                option_name = argv[ optind - 1 ];   /* yes, use argv[]  */
            else
            {                           /* ..no, invalid short option   */
                short_option[ 1 ] = (char) optopt;  /* copy option char */
                option_name = short_option + 1;     /* into "-?" string */
            }
        else                            /* valid short option...        */
        {
            short_option[ 1 ] = (char) opt; /* copy option char into    */
            option_name = short_option;     /* "-?" string              */
        }
        if ( optarg && *optarg == '-' )     /* is arg really an option? */
        {
            optopt = opt;           /* ..yes, save option without arg   */
            opt = (char) ':';       /* indicate missing option          */
            optind--;               /* back up to next option           */
        }

        /* Edit each option and its argument(s) if the option supports  */
        /* arguments.  This switch also has cases for missing argument. */
        switch( opt )
        {
            /* -------------------------------------------------------- */
            /* -d   Test script directory                               */
            /*      Used to construct absolute path names of test       */
            /*      scripts, and passed via DEFSYM to all test scripts. */
            case 'd':
                if ( have_testscript_dir++ )
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                else if ( check_arg_dir( optarg, &dir_test_scripts, option_name) )
                {
                    fprintf( stdout, "Incrementing error count on -d\n" );
                    error_count++;
                }
                break;

            /* -------------------------------------------------------- */
            /* -e   Default extension for test script filenames         */
            /*      Appended to each test script file name that lacks   */
            /*      an extension.                                       */
            case 'e':
                test_script_ext =
                        strdup( optarg[ 0 ] == '.' ? optarg + 1 : optarg );
                break;

            /* -------------------------------------------------------- */
            /* -f   Specify a test script file name.                    */
            /*      One or more file names follow the option, and       */
            /*      multiple -f options are accepted.  These file names */
            /*      are used to build the RC file used to run Hercuse.  */
            case 'f':
                while ( 1 )
                {
                    add_args_script( optarg, option_name );
                    if ( ( optind >= argc ) || ( *argv[ optind ] == (char) '-' ) )
                        break;
                    else
                        optarg = argv[ optind++ ];

                }
                break;

            /* -------------------------------------------------------- */
            /* -h   Hercules executable path                            */
            /*      Used for CreateProcess (Windows) or fork/exec       */
            /*      (UNIX-like systems).  Also used as the default for  */
            /*      the loadable module path (-p).                      */
            case 'h':
                if ( have_hercexe_path++ )
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                else if ( check_arg_hercexe( optarg, &exe_hercules, option_name ) )
                {
                    fprintf( stdout, "Incrementing error count on -h\n" );
                    error_count++;
                }
                else
                    dir_hercules = get_dirname( exe_hercules );


                break;

            /* -------------------------------------------------------- */
            /* -l   Specify a loadable module name.  File name is       */
            /*      relative to the loadable module path.  Muliple      */
            /*      loadable modules may follow the option.  Passed as  */
            /*      a -l parameter to Hercules.                         */
            case 'l':                  do
                {
                    add_load_module( optarg, option_name );
                    if ( ( optind < argc ) && ( *argv[ optind ] != (char) '-' ) )
                        optarg = argv[ optind++ ];
                    else
                        break;
                } while( 1 );
                break;

            /* -------------------------------------------------------- */
            /* -p   Loadable module directory                           */
            /*      Passed as the -p parameter to Hercules              */
            case 'p':
                if ( have_modpath_dir++ )
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                else if ( check_arg_dir( optarg, &dir_modpath, option_name ) )
                    error_count++;
                break;

            /* -------------------------------------------------------- */
            /* -q   Suppress redtest.rexx messages                      */
            /*      passed as "quiet" to redtest.rexx                   */
            case 'q':
                redtest_quiet = 1;
                break;

            /* -------------------------------------------------------- */
            /* -r   Specify test script repeat count                    */
            /*      Used to duplicate inclusion of test case scripts    */
            /*      in the RC script used as input to Hercules.         */
            case 'r':
                if ( have_repcount++ )
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                else
                {
                    rep_count = (int) strtol(optarg, &repcount_arg_end, 10);
                    if ( *repcount_arg_end != '\0' || repcount_arg_end == optarg )
                    {
                        error_count++;
                        if ( repcount_arg_end == optarg && *repcount_arg_end == '\0' )
                            msg = "Null test script repetition count\n";
                        else
                            msg = "Repetition count must be numeric and cannot include a decimal point\n";
                        fprintf( stderr, "%s", msg );
                        rep_count = 1;
                        break;
                    }
                    if ( rep_count < 1 )
                    {
                        error_count++;
                        fprintf( stderr, "Repetition count must at least one\n" );
                        rep_count = 1;
                        break;
                    }
                }
                break;

            /* -------------------------------------------------------- */
            /* -t   Specify runtest timeout default              */
            /*      Passed as the -t parameter to Hercules              */
            case 't':
                if ( have_timeout++ )
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                else
                {
                    /* strtof() would make sense here if it existed prior to C99    */
                    timeout_factor = (float) strtod(optarg, &timeout_arg_end );
                    if ( *timeout_arg_end != '\0' || timeout_arg_end == optarg )
                    {
                        error_count++;
                        if ( timeout_arg_end == optarg && *timeout_arg_end == '\0' )
                            msg = "Null timeout factor\n";
                        else
                            msg = "Timeout factor must be numeric and in the range 1 to %.1f\n";
                        fprintf( stderr, msg, timeout_limit );
                        timeout_factor = 1;
                        break;
                    }
                    if ( timeout_factor < 1 || timeout_factor > timeout_limit )
                    {
                        error_count++;
                        fprintf( stderr, "Timeout factor must be in the range 1 to %.1f\n", timeout_limit );
                        timeout_factor = 1;
                        break;
                    }
                }
                break;

            /* -------------------------------------------------------- */
            /* -v   Specify a variable=value pair.                      */
            /*      The -v argument(s) are passed as is to redtest.rexx */
            /*      without alteration *except*: platform= is not       */
            /*      allowed on the command line; this program generates */
            /*      the correct platform= value.  Func add_varval_pair  */
            /*      handles all edits.                                  */
            case 'v':
                if ( add_varval_pair( optarg, option_name, 0 ) < 0 )
                    error_count++;
                break;

            /* -------------------------------------------------------- */
            /* -w   filename for test work files                        */
            /*      Used as the file name for the workfiles required    */
            /*      for runtest (RC file, Hercules log, redtest.rexx    */
            /*      log).  We limit the filename to the POSIX portable  */
            /*      file name character set to avoid issues passing a   */
            /*      file name with embedded spaces to redtest.rexx      */
            /*      (Regina Rexx and Open Object Rexx do a terrible job */
            /*      dealing with embedded spaces).                      */
            case 'w':
                if ( have_fname_workfiles++ )   /* only one -w allowd   */
                {
                    fprintf( stdout, "%s option may be specified only once\n", option_name );
                    error_count++;
                }
                else if ( optind < argc && *argv[ optind ] != '-' )
                {                               /* only one arg allowed */
                    fprintf( stdout, "%s option may not have more than one argument\n", option_name );
                    error_count++;
                }
                if ( strlen( optarg ) != strspn( optarg, POSIX_FN_CHARS ) )
                {                   /* no spaces or specials in arg     */
                    fprintf( stdout, "%s option file name \"%s\" has invalid character\n",
                            option_name, optarg );
                    error_count++;
                }
                fname_workfiles = strdup( optarg );
                break;

            /* -------------------------------------------------------- */
            case 'x':   /* omit "exit" at end of hercules rc file       */
                no_exit = 1;
                break;

            /* -------------------------------------------------------- */
            case 1:     /* long help requested                          */
                display_help = 1;       /* suppress further options     */
                long_help();
                break;

            /* -------------------------------------------------------- */
            case 2:     /* short help requested using --help            */
                display_help = 1;       /* suppress further options     */
                short_help();
                break;

            /* -------------------------------------------------------- */
            case '?':   /* short help requested or invalid option       */
                if ( optopt == '?' )    /* is it short help?            */
                {                       /* yes, display it              */
                    display_help = 1;   /* suppress further options     */
                    short_help();
                }
                else                    /* it was invalid option        */
                {
                    fprintf( stderr, "Invalid option %s\n", option_name );
                    arg_error_count++;
                }
                break;

            /* -------------------------------------------------------- */
            case ':':   /* missing required argument                    */
                arg_error_count++;
                switch( optopt )
                {               /* options requiring directory or path  */
                    case 'd':
                    case 'h':
                    case 'p':
                        msg = "Directory name not specified";
                        break;
                    case 'e':   /* test script default extension        */
                        msg = "Test script default extension missing";
                        break;
                    case 'f':   /* test script path                     */
                        msg = "Test script name missing";
                        break;
                    case 'l':   /* loadable module name                 */
                        msg = "Loadable module name missing";
                        break;
                    case 'r':   /* repetition count                     */
                        msg = "Test script repetition count missing";
                        break;
                    case 't':   /* timeout adjustment factor            */
                        msg = "Timeout adjustment factor missing";
                        break;
                    case 'v':   /* variable=value pair missing          */
                        msg = "\"name=value\" missing";
                        break;
                    case 'w':
                        msg = "Workfile file name not specified";
                        break;
                    default:    /* SNO: this is just in case            */
                        msg = "Unknown option";
                }   /*  end switch( optopt )  */
                fprintf( stderr, "%s for option %s\n", msg, option_name );
                break;

        }  /*  end switch( opt )*/


        if ( display_help )
            break;

        longopts_index = -1;
    }   /*   end while( ... getopt_long() ...  */

    if ( arg_error_count )
        short_help();

    return error_count + arg_error_count;

}


/* ********************************************************************
    function set_defaults - Set defaults for options not set
                            on the command line.

    There are no defaults for -l, -v
    Defaults for -q, -r, -t, and -x are set as part of herctest
    initialization and are not dealt with here.
    If -v ptrsize= was not coded on the command line, one is created
    from the SIZEOF_SIZE_T #define in config.h
    -v platform= is set here.  It cannot be coded on the command line.
*/
int set_defaults( char ** argv )
{
    int    error_count = 0; /* accumulated count of errors              */
    char * result_path;     /* saved absolute result path               */
    char * platform_varval; /* pointer to platform=<platform> string    */

/* The directory options are handled first.  Note that the -p default   */
/* depends on the value for -h, and the -h default depends on the vaue  */
/* for -d, so the defaults must be set in the order -d, -h, and -p.     */

/* -d   The default is the tests subdirectory of the directory that     */
/*      herctest is run from.  If the -d option was not included in     */
/*      the command line and there is no tests subdirectory of the      */
/*      directory containing this executable, then no tests will be     */
/*      run.                                                            */

    if ( !dir_test_scripts )
    {
        if ( dir_herctest ) /* able to determine executable path?       */
                            /* ..yes, append subdir name, ensure path   */
        {                   /* ...exists.  Add subdirectory name        */
            result_path = concat_strings( dir_herctest, PATH_SEPS, TESTS_SUBDIR, NULL );
            dir_test_scripts = GET_REALPATH( result_path );
            if ( !dir_test_scripts ) /* does default path exist?            */
            {                       /* ..no, error message, done with -d    */
                fprintf( stderr, "Default test script directory \"%s\" does not exist in \"%s\"\n",
                     TESTS_SUBDIR, dir_herctest );
                error_count++;
            }
            free( result_path );
            result_path = NULL;
        }
        else                /* ..no, no root for default test scripts   */
        {
            fprintf( stderr, "Unable to determine default test scripts directory\n" );
            error_count++;
        }
    }

    /* Now that we have a test scripts directory path, see if we can    */
    /* find redtest.rexx either in the current directory or in the      */
    /* the test scripts directory.                                      */
    if( !( rexx_redtest = GET_REALPATH( REDTEST_REXX ) ) )
    {                       /* No redtest.rexx script in CWD            */
        /* Test for redtest.rexx in test scripts directory              */
        if ( dir_test_scripts )
        {
            result_path = concat_strings ( dir_test_scripts, PATH_SEPS, REDTEST_REXX, NULL );
            if( !( rexx_redtest = GET_REALPATH( result_path ) ) )
            {
                fprintf( stderr, "redtest.rexx script \"%s\" does not exist in current directory\n",
                         REDTEST_REXX );
                fprintf( stderr, "...nor in test scripts directory \"%s\"\n",
                         result_path );
                error_count++;
            }
        }
        else
        {
            result_path = NULL;
            fprintf( stderr, "redtest.rexx script \"%s\" does not exist in current directory\n",
                     REDTEST_REXX );
            error_count++;
        }

#if defined(ENCAPSULATE_REXX_REDTEST)
        /* Windows execution of redtest.rexx requires encapsulation of  */
        /* the REXX script name in double quotes.  This is not required */
        /* on UNIX-like systems.                                        */
        if ( rexx_redtest )
        {
            free( result_path );
            result_path = rexx_redtest;
            rexx_redtest = concat_strings("\"", result_path, "\"", NULL );
        }
#endif

        free( result_path );
    }


/* -h   If -h is not specified, there are two places to look for the    */
/*      hercules executable:                                            */
/*      1)  The directory containing this executable, found in          */
/*          dir_herctest (initialized in main()).                       */
/*      2)  The parent of the test scripts directory, whether specified */
/*          by a -d option or defaulted.                                */
/*      It is possible that both directories above contain a hercules   */
/*      executable.  The above order determines which is used to run    */
/*      tests.                                                          */

    if ( !exe_hercules )    /* executable specified in -h?              */
    {                       /* ..no, check the path of this executable  */
        result_path = concat_strings( dir_herctest, PATH_SEPS, HERCULES_EXE, NULL );
                            /* hercules executable in same dir as us?   */
        if( !( exe_hercules = GET_REALPATH( result_path ) ) )
        {                   /* ..no, see if in test script dir parent   */
            if ( dir_test_scripts )
            /* Test for executable in parent of tests directory         */
            {
                free( result_path );
                result_path = concat_strings( dir_test_scripts, "/../", HERCULES_EXE, NULL );
                if( !( exe_hercules = GET_REALPATH( result_path ) ) )
                {
                    fprintf( stderr, "Hercules executable \"%s\" not fond in \"%s\"\n",
                             HERCULES_EXE, dir_herctest );
                    fprintf( stderr, "...nor in parent of test directory \"%s\"\n",
                             dir_test_scripts );
                    error_count++;
                }
            }
            else            /* No test script parent directory....      */
            {
                fprintf( stderr, "Hercules executable \"%s\" not found in \"%s\"\n",
                         HERCULES_EXE, dir_herctest );
                error_count++;
            }
        }
        free( result_path );
    }

    if ( exe_hercules )
        dir_hercules = get_dirname( exe_hercules );


/* -p   If the directory from which the Hercules executable will be run */
/*      contains a ".libs" subdirectory (created by libtools) that also */
/*      contains a Hercules executable, that ".libs" directory is the   */
/*      default loadable module.  Otherwise the default loadable module */
/*      path is the directory containing the Hercules executable.       */

                                /* If no module path and have a         */
    if ( !dir_modpath && dir_hercules )   /* ..Hercules dir, use that   */
                                /* Save that directory in result_path   */
        result_path = strdup( dir_hercules ); /* must be free'able  */
    else                        /* No exe dir, so no default modpath    */
        result_path = NULL;

#if defined(LIBTOOL_SUBDIR)     /* Windows and Apple don't use GNU LT   */
    if ( result_path )          /* any candidate exe directory?         */
    {                           /* see if exec dir has a .libs dir      */
        char * save_modpath;    /* used in test for .libs subdir        */
        char * work_path;       /* ..this one too.                      */

        work_path = concat_strings( result_path, PATH_SEPS, LIBTOOL_SUBDIR, NULL );
        save_modpath = GET_REALPATH( work_path );
        free( work_path );
        if ( save_modpath )     /* does <exedir>/.libs exist?           */
        {                       /* ..yes, it becomes the result         */
            free( result_path );
            result_path = save_modpath;
        }
    }
#endif

    if ( result_path )          /* no .libs or platform does not use it */
        dir_modpath = result_path;    /* default is exe directory       */


/* -f   The default is "-f  *.tst" to run all test scripts in the tests */
/*      directory.  Because full paths are added from a directory scan  */
/*      and are known to exist, a flag is set to bypass validation of   */
/*      the test script array.                                          */

    if ( args_scripts.index < 0 )   /* Any test scripts specified?      */
    {                               /* ..no, add default script         */
        result_path = concat_strings(
                dir_test_scripts,   /* test script directory            */
                                    /* add path sep and "*.tst" to it   */
                WILDCARD_DIR, ".", TEST_SCRIPT_EXT, NULL );
        fprintf( stdout, "Option -f not specified; assuming \"-f %s\n",
                result_path );
        add_args_script( result_path, "Default script" );
        free( result_path );
    }


/*  -t <factor>: If a timeout factor was provided, then we convert it   */
/*      to string form here.  Otherwise, we set a default of 1.0.       */
/*      Rather than use snprintf(), which is not available prior to c99 */
/*      and not avaialable in MSVC prior to Visual Studio 15, we        */
/*      the timout factor "by hand," taking into account the limited    */
/*      range of valid timeout factors.                                 */
    if ( timeout_factor <= 1.0 )
        strcpy( timeout_factor_s, "-t1.0" );
    else
    {
        int i = 0;             /* position following '-t" in ascii str */
        int i_timeout_factor;  /* Integer timeout factor * 10          */
                               /* ..e.g., 12.2 becomes 122.            */
        if ( timeout_factor > timeout_limit ) 
            timeout_factor = timeout_limit;
        timeout_factor_s[ i++ ] = '-';
        timeout_factor_s[ i++ ] = 't';
        i_timeout_factor = (int) ( ( timeout_factor + .05f ) * 10 );
        if ( i_timeout_factor > 99 )
        {
            timeout_factor_s [ i++ ] = i_timeout_factor / 100 + '0';
            i_timeout_factor %= 100;
        }
        timeout_factor_s [ i++ ] = i_timeout_factor / 10 + '0';
        if ( i_timeout_factor%10 )
        {
            timeout_factor_s [ i++ ] = '.';
            timeout_factor_s [ i++ ] = i_timeout_factor % 10 + '0';
        }
        timeout_factor_s[ i ] = '\0';
    }

/* -v ptrsize=4 | 8: The default is the value of SIZEOF_SIZE_P in the   */
/*      config.h file in the Hercules executable directory.  If         */
/*      "-v ptrsize=" is not specified and either config.h cannot be    */
/*      located or does not contain an identifiable SIZEOF_SIZE_P       */
/*      macro, an error message is issued and no tests are run.         */

    if ( !ptrsize_found )
        error_count += get_ptrsize();


/* -v platform=<platform>: This is not really setting a default because */
/*      this option is not allowed to be set on the command line.  But  */
/*      this is as good a place as any to set it.  On Windows, there is */
/*      only one platform, "Windows."  On UNIX-like systems, we use     */
/*      the uname function to retrieve the value of `uname -s`.         */

#if defined(PLATFORM_VALUE)
    platform_varval = concat_strings( PLATFORM_NAME, "=",
            PLATFORM_VALUE, NULL );
#else
    {                       /* use `uname -s` as platform name          */
	    struct utsname uname_result;
	    uname( &uname_result);
        platform_varval = concat_strings( PLATFORM_NAME, "=",
                uname_result.sysname, NULL );
    }
#endif
    error_count += add_varval_pair( platform_varval, "Platform name,", 1 );
    free( platform_varval );


/* -w   The default work file name is "allTests"                        */
    if ( !fname_workfiles )
        fname_workfiles = strdup( FNAME_WORKFILES );
    herc_rc_file = concat_strings( fname_workfiles, HERC_RC_EXT, NULL );
    herc_log   = concat_strings( fname_workfiles, HERC_LOG_EXT, NULL );
    redtest_log  = concat_strings( fname_workfiles, REDTEST_LOG_EXT, NULL );

    return error_count;
}


/* ********************************************************************
    Function validate_arg_scripts_array

    Return 1 if the filename passed has an extension, 0 otherwise.
    Filename may be absolute or relative.  Extensions on directory
    portions of the filename are not relevant to this test and are
    ignored.

    This routine comes in two versions, Windows and UNIX-like/macOS.
    In both cases, the resulting array is sorted by test name.  A
    separate qsort() is used for Windows, and alphasort is included
    in the scandir() call on UNIX-like systems.

    Do the following:
    1.  If any wildcard characters ('*', '?', '[') appear,
        a.  glob the string.  Relative paths are interpreted by glob()
            as relative to the current directory.
        b.  If there are no matches and the input is a relative path,
            prefix the input with the test scripts directory name and
            repeat the glob.
        c.  If there are still no matches, error message and exit.
    2.  Absent wildcard characters, realpath the input path to test for
        existence and cannonicalize the path.
    3.  Use access to determine that the file is readable.
*/

int validate_arg_scripts_array()
{
    size_t i;                   /* to copy glob result to test scripts  */

    int error_count = 0;        /* Count of errors detected             */
    int arg_idx;                /* Current index to argument scripts    */
    int glob_error = 0;         /* return code from glob()              */

    char * fake_glob[ 2 ];      /* fake result from glob when doing a   */
                                /* path without wildcards.              */
    char * work_path;           /* working path                         */
    char * work_path_tsd;       /* working path with test script dir    */

    glob_t glob_result;         /* structure for glob(); includes       */
                                /* array of results of globbing         */

    glob_result.gl_pathc = 0;   /* count of total paths so far          */
    glob_result.gl_offs = 0;    /* reserved at beginning of gl_pathv    */
    glob_result.gl_pathv = NULL;    /* list of paths matching pattern   */

    errno = 0;

    for ( arg_idx = 0; arg_idx <= args_scripts.index; arg_idx++ )
    {
        if ( !strpbrk( args_scripts.string[ arg_idx ], GLOBBING_CHARS ) )
                            /* No wildcards.  Dummy up glob result      */
        {
            fake_glob[ 0 ] = args_scripts.string[ arg_idx ];
            fake_glob[ 1 ] = NULL;
            glob_result.gl_pathv = fake_glob;
            glob_result.gl_pathc = 1;
        }
        else
        {
            glob_error = GLOB( args_scripts.string[ arg_idx ], 0, NULL, &glob_result );
            if ( !glob_result.gl_pathc )    /* if no matches, and a         */
                                /* relative path was provided, see if there */
            {                   /* are any matches in the test scripts dir  */
                if ( *args_scripts.string[ arg_idx ] == PATH_SEPC )
                {               /* absolute path and no match.  error msg   */
                    fprintf( stderr, "No files match \"%s\"\n", args_scripts.string[ arg_idx ] );
                    error_count++;
                    continue;   /* on to the next argument script entry */
                }
                else            /* relative path.  See if it works in   */
                {               /* the test script directory            */
                    work_path_tsd = concat_strings( dir_test_scripts, PATH_SEPS,
                            args_scripts.string[ arg_idx ], NULL );
                    glob_error = GLOB( work_path_tsd , 0, NULL, &glob_result );
                    free( work_path_tsd );
                    if ( !glob_result.gl_pathc )    /* nope, no matches */
                    {
                        fprintf( stderr, "No files match \"%s\" in current dir or test scripts dir \"%s\"\n",
                                args_scripts.string[ arg_idx ], dir_test_scripts );
                        error_count++;
                        continue;   /* on to next argument script entry */
                    }
                }
            }
        }

        /* We now have an array of one or more strings in glob_result.  */
        /* If glob populated glob_result, the files therein do exist,   */
        /* otherwise existence must be checked.  This means if          */
        /* GET_REALPATH returns not found (NULL), we know only a single */
        /* file was being worked from the arg_scripts array, and our    */
        /* file was being tailored accordingly.                         */

        for( i = 0; i < glob_result.gl_pathc; i++ )
        {
            work_path = GET_REALPATH( glob_result.gl_pathv[ i ] );
            if ( !work_path )   /* non-existent path?                   */
            {
                if( *glob_result.gl_pathv[ i ] == PATH_SEPC )
                {               /* absolute path. we are done with it   */
                    fprintf( stderr, "File \"%s\" does not exist\n", glob_result.gl_pathv[ i ] );
                    error_count++;
                    continue;   /* do not add this one to test_scripts  */
                }
                else            /* relative path.  prefix with test     */
                {               /* ...script dir and try again          */
                    work_path_tsd = concat_strings( dir_test_scripts, PATH_SEPS,
                            glob_result.gl_pathv[ i ], NULL );
                    work_path = GET_REALPATH( work_path_tsd );
                    free( work_path_tsd );
                    if ( !work_path )   /* still a non-existent path?   */
                    {                   /* ..yes, error message         */
                        fprintf( stderr, "File \"%s\" does not exist in current dir or test scripts dir \"%s\"\n",
                                glob_result.gl_pathv[ i ], dir_test_scripts );
                        error_count++;
                        continue;   /* do not add this to test_scripts  */
                    }
                }
            }

            /* path exists.  Ensure file can be read                    */
            if ( ACCESS( work_path, R_OK ) )     /* rc=0 means readable */
            {                   /* not readable.  Error message...      */
                fprintf( stderr, "File lacks read permissions: \"%s\"\n", work_path );
                free( work_path );
                error_count++;
            }
            else                /* extant and readable.  Add it.        */
                addto_string_array( &test_scripts, work_path );
        }
    }


                            /* did glob() provide the strings?          */
    if ( glob_result.gl_pathv != fake_glob )
        GLOBFREE( &glob_result );   /* ..yes,  free storage.            */

    return error_count;

}


/* ********************************************************************
    Function validate_loadables - validate loadable module names

    Do the following for each loadable module:
    1)  Ensure each loadable module exists in the modpath directory
        and is readable.
    2)  If the loadable module does not exist or is not readable, issue
        an error message and increment the error count

    Return codes:
    0   - all loadable modules exist in the directory specified by
          -p or --modpath.
    >0 - number of loadable modules that do not exist or cannot be read.

*/
int validate_loadables()
{
    int error_count = 0;    /* accumulated count of errors              */
    int i;                  /* load module array loop control           */
    char * work_path;       /* working path of loadable module          */
    char * work_path_real;  /* real working path of loadable module     */

    if ( loadmod.index >= 0 )
    {
        for ( i = 0; i <= loadmod.index; i++ )
        {                   /* build module absolute path               */
            work_path = concat_strings( dir_modpath, PATH_SEPS,
                loadmod.string[ i ], NULL );
            work_path_real = GET_REALPATH( work_path );
            free( work_path );
            if ( !work_path_real )  /* non-existent path?               */
            {               /* ..yes, error message                     */
                fprintf( stderr, "Loadable module \"%s\" not found in modpath \"%s\"\n",
                        loadmod.string[ i ], dir_modpath );
                error_count++;
            }
                            /* Loadable module exists.  Ensure readable */
            else if ( ACCESS( work_path_real, R_OK ) ) /* rc=0 -> yes   */
            {                   /* not readable.  Error message...      */
                fprintf( stderr, "Loadable module \"%s\" lacks read permissions\n",
                    work_path_real );
                error_count++;
            }
            free( work_path_real );
        }
    }

    return error_count;
}


/* ********************************************************************
    Function build_test_script_rc_file() - build rc file for Hercules

    Convert the list of test scripts in the test_scripts array into
    an RC file for Hercules to run the scripts.  The RC file itself
    is timestamped with a comment line at the beginning, and each
    file referenced in the RC file has its last modification timestamp
    included just before the file.

    To keep the RC file small, script comands are used to include each
    test script in the RC file; the test files themselves are not
    copied.  The result is an RC file that is almost entirely comments,
    but the Hercules log created when this is run makes much more
    sense.
*/

int build_test_script_rc_file()
{
    char * mos[] = {    "Jan", "Feb", "Mar",
                        "Apr", "May", "Jun",
                        "Jul", "Aug", "Sep",
                        "Oct", "Nov", "Sep"};

    char * days[] = {   "Sun", "Mon", "Tue",
                        "Wed", "Thu", "Fri",
                        "Sat" };

    char * stars = "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n";
    char * onestar = "*\n";

    time_t t_in_secs;       /* time in seconds since epoch              */
    struct tm stimeu;       /* UTC system time, in useful vars          */
    struct tm ftimeu;       /* test script UTC mod. time in useful vars */

    struct stat fst;        /* to stat test script for last mod. time   */

    FILE * fd_rc;           /* file desc. for Hercules RC file          */

    int i;                  /* loop control for test scripts            */
    int j;                  /* loop control for script repetition       */

    t_in_secs = time(NULL);  /* get system time                         */
    stimeu = *gmtime( &t_in_secs );  /* convert to UTC values            */


/*  Test script preamble: initialize input and output file names, make  */
/*  sure the files are empty by deleting them                           */

    fd_rc = fopen( herc_rc_file, "w" );     /* open and trunc output    */
    if ( !fd_rc )
    {
        fprintf( stderr, "Unable to open \"%s\", errno %d\n", herc_rc_file, errno );
        return 1;
    }

    fprintf( stdout, "Building Hercules RC file \"%s\"\n", herc_rc_file );

    /* More preamble: provide the RC creation time in a comment and     */
    /* the test case directory in a symbol.                             */

    fputs( stars,    fd_rc );
    fputs( onestar,  fd_rc );
    fprintf( fd_rc, "* Hercules runtest RC file created %s %d-%s-%d %2.2d:%2.2d:%2.2d UTC\n",
            days[ stimeu.tm_wday ],
            stimeu.tm_mday, mos[ stimeu.tm_mon ], stimeu.tm_year + 1900,
            stimeu.tm_hour, stimeu.tm_min, stimeu.tm_sec );
    fputs( "\n",  fd_rc );
    fprintf( fd_rc, "defsym testpath \"%s\"\n", dir_test_scripts );
    fputs( "\n",  fd_rc );
    fputs( stars, fd_rc );

    /* Write a script command for each test script to the rc file that  */
    /* Hercules will execute.  If tests are to be repeated, write the   */
    /* script command once for each repetition specified by -r.         */

    for ( i = 0; i <= test_scripts.index; i++ )
    {
        /* stat the file to get the modification time.  The file is     */
        /* known to exist, so error checking should not be required.    */
        stat( test_scripts.string[ i ], &fst ); /* get last mod time    */
        ftimeu = *gmtime( &fst.st_mtime );  /* convert to UTC values    */

        fputs( "\n\n",   fd_rc );
        fputs( stars,    fd_rc );
        fputs( onestar,  fd_rc );
        fprintf( fd_rc,  "* Start of test script %s\n", test_scripts.string[ i ] );
        fprintf( fd_rc,  "*     ...last modified %s %d-%s-%d %2.2d:%2.2d:%2.2d UTC\n",
            days[ ftimeu.tm_wday ],
            ftimeu.tm_mday, mos[ ftimeu.tm_mon ], ftimeu.tm_year + 1900,
            ftimeu.tm_hour, ftimeu.tm_min, ftimeu.tm_sec );
        fputs( onestar,  fd_rc );
        fputs( stars,    fd_rc );

        for ( j = 1; j <= rep_count ; j++ )
        {
            fprintf( fd_rc, "script \"%s\"", test_scripts.string[ i ] );
            if ( j < rep_count )
            {
                fputs( "\n\n",   fd_rc );
                fputs( stars,    fd_rc );
                fputs( onestar,  fd_rc );
                fprintf( fd_rc, "* Repetition %d of test file %s\n", j, test_scripts.string[ i ] );
                fputs( onestar,  fd_rc );
                fputs( stars,    fd_rc );
                fputs( "\n\n",   fd_rc );
            }
        }               /* for ( j = 1; j <= rep_count ; j++ )          */
    }                   /* for ( i = 0; i < test_scripts.index; i++ )   */

    fputs( "\n\n",   fd_rc );
    fputs( stars,    fd_rc );
    fputs( onestar,  fd_rc );
    fprintf( fd_rc, "* End of Hercules test case input script\n" );
    fputs( "\n",  fd_rc );

    if ( !no_exit )         /* include exit unless supressed with -x    */
    {
        fputs( "\n\n",   fd_rc );
        fprintf( fd_rc, "exit\n\n" );
    }

    fclose( fd_rc );

    return 0;

}


/* ********************************************************************
    Function build_hercules_arglist() - build argument list

    Create the c-style argc/argv argument list needed to fork/exec
    Hercules.  The following command line options to this program
    are used in order as coded or defaulted.

    -h  argv[ 0 ]: Absolute path used to invoke Hercules
        argv[ 1 [: "-r <herc_rc_file>"  commands for Hercules
    -t  argv[ 2 ]: "-tn.n" to indicate the timeout option
    -p  argv[ 3 ]: "-p" to indicate the modpath option
        argv[ 4 ]: modpath loadable module directory

    If loadable modules were named on the command line, the argv listt
    continues with:

    -l  argv[ 5 ]: "-l" to indicate a loadable module
        argv[ 6 ]: name of a loadable module

    Additional -l options follow the first if more than one was
    provided to this program.
*/

int build_hercules_arglist()
{

    int i;                  /* loop control over procargs array         */
    addto_string_array( &procargs, exe_hercules );

    addto_string_array( &procargs, "-r" );
    addto_string_array( &procargs, herc_rc_file );

    addto_string_array( &procargs, timeout_factor_s );

    addto_string_array( &procargs, "-p" );
    addto_string_array( &procargs, dir_modpath );

    for ( i = 0; i <= loadmod.index; i++ )
    {
        addto_string_array( &procargs, "-l" );
        addto_string_array( &procargs, loadmod.string[ i ] );
    }

    addto_string_array( &procargs, NULL );  /* NULL-terminate arg list  */

    return 0;

}


/* ********************************************************************
    Function build_redtest_arglist() -

    Create the c-style argc/argv argument list needed to fork/exec
    the installed REXX interpreter.  On UNIX-like systems, this is
    straightforward: executable is named rexx, and the first
    parameter, argv[ 1 ], is the script name.

    The Windows command interpreter does not create an argc/argv
    structure to pass parameters and options; rather, it just
    provides a single command line.  The Windows c runtime creates
    argc/argv, stripping any quotes in the process.  Open Object Rexx
    re-assembles this quote-stripped argv array back to a single
    command line without putting the quotes back and then uses what it
    sees as the first parameter as the script name.  If there were
    embedded spaces in the script path, the process fails.

    Graphically:

        rexx.exe "s c r i p t.rexx" "parm1" "parm2"

    becomes an argv array like this

        argv[ 0 ] -> rexx.exe
        argv[ 1 ] -> s c r i p t.rexx
        argv[ 2 ] -> parm1
        argv[ 3 ] -> parm2

    which ooRexx re-assembles into:

        rexx.exe s c r i p t.rexx parm1 parm2

    and this fails because ooRexx looks for a script named "s.rexx"
    and will, if s.rexx is found, pass it s c r i p t .rexx parm1 parm2

    The following REXX command line is built when running on UNIX-like
    systems:

        argv[ 0 ]: rexx executabe "rexx"
        argv[ 1 ]: test script directory suffixed with redtest.rexx
        argv[ 2 ]: filename of the log file created by the Hercules
                   execution.  This file is in the current directory
                   and is used as input to redtest.rexx.

    If -v options or -q was specified, continue with elements from
    the varval string array.

        argv[ 3 ]: first varval string

    The following REXX command line is built when running on Windows
    systems:

        argv[ 0 ]: Windows command line interpreter "cmd.exe"
        argv[ 1 ]: "/c" - cmd.exe flag: execute command line contents
        argv[ 2 ]: test script directory suffixed with redtest.rexx
        argv[ 3 ]: filename of the log file created by the Hercules
                   execution.  This file is in the current directory
                   and is used as input to redtest.rexx.

    If -v options or -q was specified, continue with elements from
    the varval string array.

        argv[ 4 ]: first varval string

    Additional varval strings follow the first if more than one was
    added to the varval array.

    The procargs array is reused.  The index is reset to -1 but the
    current allocation is retained.  If it needs to grow (not likely),
    so be it.
*/

int build_redtest_arglist()
{

    int i;                  /* loop control over procargs array         */

    procargs.index = -1;    /* empty the procargs string array          */
                            /* ..no strings must be free'd              */

                            /* add rexx(.exe) cmd as argv[ 0 ]          */

    addto_string_array( &procargs, REXX_EXE );  /* ..used as executable */

#if defined(REXX_EXE_FLAGS)
    addto_string_array( &procargs, REXX_EXE_FLAGS );
#endif

    addto_string_array( &procargs, rexx_redtest );  /* add REXX script  */
    addto_string_array( &procargs, herc_log );  /* add input file name  */

    if ( redtest_quiet )
        addto_string_array( &procargs, QUIET_NAME );/* add quiet option */

    for ( i = 0; i <= varval.index; i++ )
        addto_string_array( &procargs, varval.string[ i ] );

    addto_string_array( &procargs, NULL );  /* NULL-terminate arg list  */

    return 0;

}


/* ********************************************************************
    Function run_child_process: Run a child process and await completion

    Arguments:
    -   char * procname: a descriptive name for the child process.
            Used only in messages.
    -   char * outfile: string naming the file to which stdout and
            stderr should be redirected.
    -   int quote_args: (used by Windows version only) 1 if each
            Hercules argument should be encapsulated in double quotes,
            0 otherwise.  Needed for a Hercules command line, not
            needed for a redtest.rexx command line.
    -   int * child_ec: return code from a successfully-executed
            child process.

    Two versions of this routine exist, one for Windows and one for
    UNIX-like platforms.  The platforms differ in the method and
    parameter list structure used to spawn a process and await its
    completion.

    In both cases, the procargs array is used as the source for the
    parameter list structure.

    The procargs array is used as the argv vector for the parameter
    list to exec.  Because the procargs array includes the terminating
    NULL in its count, argc is set to one less than the array element
    count.
*/
#if defined(_WIN32)
/*
    The procargs array is used to construct a single character string
    command line.  If requested by the caller, all arguments retrieved
    from procargs are encapsulated in double quotes to enable use of
    path and file names with embedded spaces.

    The encapsulating double quotes are removed when the Windows c
    runtime parses the command line into the argc/argv structure
    expected by a c program.

    Because Regina Rexx re-assembles a single command line from the
    argc/argv structure and Open Object Rexx retrieves the original
    Windows command line, encapsulation creates a different command
    line based on the REXX interpreter in use.  So instead we forbid
    spaces and other special characters in the file names passed to
    redtest.rexx and allow the caller to supress encapsulation.

    The code surrounding the CreateProcess call is taken from
    Microsoft at:

    https://docs.microsoft.com/en-us/windows/desktop/ProcThread/creating-processes

*/
int run_child_process(
        const char * procname,
        const char * outfile,
        int quote_str,
        int * child_rc )
{

    char * cmdline = NULL;  /* cmd line assembled from hercarg array    */
    size_t cmdline_size = 0;    /* current size of cmd line allocation  */
    size_t arg_extra_len = 1;   /* len of any trailing space and quotes */
    size_t cmdline_len = 0;     /* current length of cmdline string     */
                            /* ..does not include trailing '\0'         */
    size_t arglen;          /* length of next string to add to cmdline  */

    int i;                  /* loop control for traversing procargs     */

    int error_count = 0;    /* count of errors detected, forms rc       */
    DWORD child_exit;       /* child process exit status                */

                            /* Structures and handles needed for        */
                            /* Windows process creation and file        */
                            /* handle redirection                       */
    STARTUPINFO si;     /* Windows process startup infrormation block   */
    PROCESS_INFORMATION pi;     /* Windows  process information block   */
    SECURITY_ATTRIBUTES sa;     /* security attributes for file handles */
    HANDLE ho;          /* handle for output file                       */

    memset( &pi, '\0', sizeof( PROCESS_INFORMATION ) );
    memset( &si, '\0', sizeof( STARTUPINFO ) );
    memset( &sa, '\0', sizeof( SECURITY_ATTRIBUTES ) );

    si.cb = sizeof( STARTUPINFO );
    sa.nLength = sizeof( SECURITY_ATTRIBUTES );

    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    ho = CreateFile( outfile,   /* create a file handle                 */
            FILE_WRITE_DATA,    /* Writing file                         */
                                /* file access permissions              */
            FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
            &sa,                /* Security attribute structure         */
            CREATE_ALWAYS,      /* always create; overwrite existing    */
            FILE_ATTRIBUTE_NORMAL,  /* extended attributes              */
            NULL );             /* no template                          */

    si.dwFlags |= STARTF_USESTDHANDLES;
    si.hStdOutput = ho;         /* redirect stdout to new file's handle */
    si.hStdError = ho;          /* ...likewise stderr                   */

    /* assemble the single command line needed to start a Windows       */
    /* process.                                                         */

    if ( quote_str )            /* encapsulating in double quotes?      */
        arg_extra_len += 2;     /* ..yes, allow for their length        */
    cmdline_size = CMDLINE_ALLOC;
    cmdline = (char *) malloc( cmdline_size );
    *cmdline = '\0';

    for ( i = 0; i < procargs.index; i++)
    {
        /* allow for string, quotes, and trailing space                 */
        arglen = strlen( procargs.string[ i ] ) + arg_extra_len;
        if ( ( arglen + cmdline_len + 1 ) > cmdline_size )
        {
            cmdline_size = cmdline_size + arglen + CMDLINE_ALLOC;
            cmdline = (char *) realloc( cmdline, cmdline_size );
        }
        if ( quote_str )                /* encasulate in double quotes? */
        {                               /* ..yes                        */
            strcat( cmdline, "\"" );    /* leading double quote         */
            strcat( cmdline, procargs.string[ i ] );    /* arg string   */
            strcat( cmdline, "\" " );   /* trailing double quote, space */
        }
        else
        {                               /* ..no, trailing space will do */
            strcat( cmdline, procargs.string[ i ] );    /* arg string   */
            strcat( cmdline, " " );     /* trailing space               */
        }
        cmdline_len += arglen;      /* update current command line len  */
    }

#if defined(DUMP_GLOBALS)
    printf( "%s command line is %s\n", procname, cmdline );
#endif

    /* No executable name is passed to CreateProcess in its first       */
    /* parameter, and CreateProcess therefore uses the first token in   */
    /* the command line string (second parameter) and uses the normal   */
    /* Winows executable search process.                                */

    /* Run Hercules as a started process.                               */
    if ( !CreateProcess(
            NULL,       /* NULL: no specific executable                 */
            cmdline,    /* Command line incl. executable name           */
            NULL,       /* Process handle not inheritable               */
            NULL,       /* Thread handle not inheritable                */
            TRUE,       /* enable handle inheritance, required to       */
                        /* ...enable redirection of stdout/stderr       */
            0,          /* No creation flags                            */
            NULL,       /* Use parent's environment block               */
            NULL,       /* Use parent's starting directory              */
            &si,        /* Pointer to STARTUPINFO structure             */
            &pi )       /* Pointer to PROCESS_INFORMATION structure     */
            )
    {                       /* process start failed                     */
        fprintf( stderr, "CreateProcess for %s failed, error %d\n",
                procname, GetLastError() );
        error_count++;
    }
    else                    /* Process started successfully             */
    {
        fprintf( stdout, "Starting %s, child PID %d...", procname,
                pi.dwProcessId );

        /* Wait until child process exits.                              */
        WaitForSingleObject( pi.hProcess, INFINITE );

        GetExitCodeProcess( pi.hProcess, &child_exit );
        fprintf( stdout, "exit rc %d\n", child_exit );
        * child_rc = child_exit;

        /* Close process and thread handles.                            */
        CloseHandle( pi.hProcess );
        CloseHandle( pi.hThread );
    }

    free( cmdline );
    return error_count;

}
#else
/*
    The procargs array is used as the argv vector for the parameter
    list to execvp.

    The tricky bit to fork/exec on UNIX-like systems is maintaining
    access to the parent process stderr so that errors in the last bits
    of fork/exec process can be displayed where humans can readily see
    them.
*/
int run_child_process(
        const char * procname,
        const char * outfile,
        int quote_str,
        int * child_rc )
{
    pid_t new_proc;         /* PID of child process                     */
    int error_count = 0;    /* accumulated count of errors              */
    int child_exit = 0;     /* child process exit status                */
    int old_stderr;         /* file descriptor of old stderr            */
    FILE * fd_stderr;       /* file handle of old stderr                */

    fflush( stdout );       /* flush buffers before fork                */
    fflush( stderr );       /* ...                                      */


    new_proc = fork();      /* fork this process                        */

    if ( new_proc < 0 )     /* -1, fork failed                          */
    {
        fprintf( stderr, "Fork of Hercules process failed, errno %d\n", errno );
        error_count++;
    }

    else if ( new_proc == 0 )
    /* we are the child process.  Save the current stderr so we can     */
    /* display errors to the caller.  Redirect stdin, stdout, and       */
    /* stderr and execvp the child process's intended executable.       */
    /* There is no return from execvp, and so this leg of the if/if     */
    /* else/else never continues.                                       */
    {
        old_stderr = dup( STDERR_FILENO );
        fd_stderr = fdopen( old_stderr, "a" );
        if( !freopen( outfile, "w", stdout ) )      /* open stdout      */
        {
            fprintf( fd_stderr, "freopen output of %s failed, errno %d\n",
                    herc_log, errno );
            exit( 127 );    /* ..failed, exit process with rc           */
        }
        if( ( dup2( STDOUT_FILENO, STDERR_FILENO ) < 0 ) )
        {
            fprintf( fd_stderr, "dup2 of stderr to stdout failed, errno %d\n",
                    errno );
            exit( 127 );    /* ..failed, exit process with rc           */
        }
        if ( execvp( procargs.string[ 0 ], procargs.string ) )
        {
            fprintf( fd_stderr, "execvp of %s failed, errno %d\n",
                    procargs.string[ 0 ], errno );
            exit( 127 );    /* ..failed, exit process with rc           */
        }
    }

    /* We are the parent process.  Await child process completion.      */
    fprintf( stdout, "Starting %s, child PID %d...", procname, (int) new_proc );
    fflush( stdout );           /* force display of partial line        */
    waitpid( new_proc, &child_exit, 0 );    /* await process end        */
    *child_rc = WEXITSTATUS( child_exit );
    fprintf( stdout, "exit RC %d\n", *child_rc );

    return error_count;
}
#endif


#if defined(DUMP_GLOBALS)
/* ********************************************************************
    Function dump_globals: dump global variables for debugging

    Arguments: none.

    Global variables are dumped to stdout in what should be human-
    readable form.  Depends on the human I suppose.
*/
void dump_globals( int rc )     /* Dump global variables                 */
{

    struct array_s {            /* array describing arrays to be dumped */
        struct stringctl_s * str_array;     /* ..pointer to array       */
        char        * desc;                 /* ..descriptive phrase     */
    };

    struct array_s array_list[ 6 ] =        /* list of arrays to dump   */
    {
        NULL,           "             ",
        &loadmod,       "Load modules:",
        &varval,        "-v options:  ",
        &args_scripts,  "-f arguments:",
        &test_scripts,  "Test Scripts:",
        &procargs,      "Child args:  "
    };

    int array_count = 6;        /* count of array elements              */

    int i;                  /* Loop control over arrays being dumped    */
    int j;                  /* loop control over array of arrays        */

    char * msg;

    fprintf( stdout, "\n--------------------------------------------------------\n");
    fprintf( stdout, "Herctest executable dir      = %p -> \"%s\"\n", dir_herctest, dir_herctest );
    fprintf( stdout, "Herctest file name           = %p -> \"%s\"\n", name_herctest, name_herctest );
    fprintf( stdout, "Test Script directory        = %p -> \"%s\"\n", dir_test_scripts, dir_test_scripts );
    fprintf( stdout, "Loadable modules directory   = %p -> \"%s\"\n", dir_modpath, dir_modpath );
    fprintf( stdout, "Hercules executable dir      = %p -> \"%s\"\n", dir_hercules, dir_hercules );
    fprintf( stdout, "Hercules executable path     = %p -> \"%s\"\n", exe_hercules, exe_hercules );
    fprintf( stdout, "Workfile file name           = %p -> \"%s\"\n", dir_herctest, fname_workfiles );
    fprintf( stdout, "Herctest executable dir      = %p -> \"%s\"\n", dir_herctest, dir_herctest );
    fprintf( stdout, "Herctest file name           = %p -> \"%s\"\n", name_herctest, name_herctest );

    fprintf( stdout, "Last default test script ext = %p -> \"%s\"\n", test_script_ext, test_script_ext );
    fprintf( stdout, "Timeout adjustment factor    = %.1f    (max %.1f)\n",
            timeout_factor, timeout_limit );
    fprintf( stdout, "Repetition count             = %d\n", rep_count );
    fprintf( stdout, "\n" );

    fprintf( stdout, "%s reddest.rexx -v quiet\n", redtest_quiet ? "Include" : "Exclude" );
    fprintf( stdout, "%s exit in hercules RC file\n", no_exit ? "Exclude" : "Include" );
    fprintf( stdout, "-v ptrsize=n %sfound\n", ptrsize_found ? "" : "not " );
    fprintf( stdout, "\n" );


    /* dump the contents of the string arrays.  Skip empty arrays, and  */
    /* skip entries that are empty too.                                 */
    for ( j = 1;  j < array_count; j++ )
    {
        if ( array_list[ j ].str_array->index >= 0 )
        {
            msg = array_list[ j ].desc;
            for ( i = 0; i <= array_list[ j ].str_array->index; i++ )
            {
                if ( array_list[ j ].str_array->string[ i ] )
                {
                    fprintf( stdout, "%s %3d. %p -> \"%s\"\n", msg, i + 1,
                            array_list[ j ].str_array->string[ i ],
                            array_list[ j ].str_array->string[ i ] );
                    msg = array_list[ 0 ].desc;
                }
            }
            fprintf( stdout, "\n" );
        }
    }


    fprintf( stdout, "\n--------------------------------------------------------\n");

}
#endif


/* ********************************************************************
    Function addto_string_array: Add element to string array

    Arguments:
    1. Address of the string array to which the new string will be added
    2. Element (a string) to be added to the array

    If there is no room in the array or the array has not been used yet,
    this routine will perform an initial allocation or will increase
    the allocation of array.

    Note: the string array is really an array of malloc'd pointers.  All
    strings in the array must be malloc'd; pointer references to command
    line parameters are not permitted.  It should be possible to use
    free() on each of the array's elements.
*/
int addto_string_array(
            stringctl_t * str_array,    /* array to receive string      */
            char * element              /* string to be added           */
            )
{
                                /* room for another string?             */
    if ( ++str_array->index >= str_array->alloc )
                                /* ..no, (re)allocate string array      */
    {
        str_array->alloc += str_array->next_alloc;  /* increase alloc   */
                                /* allocate more string array space     */
        str_array->string = (char **)
                realloc( str_array->string, sizeof(size_t) * str_array->alloc);
    }

    str_array->string[ str_array->index ] = element;    /* Add element  */

    return 0;
}


/* ********************************************************************
    Concatenate two or more strings into a single string.  Return a
    pointer to the result string; this pointer is malloc'd and may be
    free'd at any appropriate time.

    The strings to be concatenated are passed as parameters; the end of
    the parameter list is indicated by NULL.

    To prevent run-aways, each string must be less than MAX_PATH in
    length, and no more than 50 strings may be provided as parameters.

    The astute reader may note that much of this could have been done
    with a large buffer and snprintf().  This approach was rejected
    because buffer size issues would stil need to be addressed, because
    different format strings would needed based on the number of
    strings to be concatenated, and because either this routine or the
    caller would need to transfer the result string to malloc'd storage
    via strdup.
*/
char * concat_strings( char * str, ...) /* NULL must be last parm               */
{
    char * res_string;                  /* result string                        */
    char * in_str;                      /* next string to be appened to result  */
    int arg_count = 0;                  /* to limit number of strings appended  */
    size_t res_len = CONCAT_RES_LEN;    /* initial malloc size for result       */


    va_list args;                       /* initialize va_list structure         */

    res_string = (char *) malloc( res_len );  /* allocate result string...      */
    *res_string = '\0';                 /* ..and initialize to null             */

    va_start( args, str );              /* init. variadic argument processing   */
    in_str = str;                       /* point to first argument              */

    while ( in_str )                    /* NULL ptr ends parm list              */
    {
        if (arg_count++ > CONCAT_MAX_ARGS)  /* reached parm count upper limit?  */
            break;                          /* ..yes, stop string concatenation */
        if ( strlen( in_str ) > MAX_PATH )  /* string too long?                 */
            in_str = CONCAT_TOO_LONG;       /* ..yes, use diagnostic string     */
                                            /* is result string too long?       */
        if ( (strlen(res_string) + strlen(in_str) + 1) > res_len )
        {                                   /* ..yes, get new result area       */
                                            /* calc size of new result storage  */
            res_len = res_len + strlen(in_str) + CONCAT_RES_LEN;
                                            /* get larger result area           */
            res_string = (char *) realloc( res_string, res_len );
        }
        strcat( res_string, in_str );       /* add next string to result        */
        in_str = va_arg( args, char * );    /* point to next argument           */
    }

    va_end( args );                         /* end variadic arg processing      */

                                            /* create exact-sized result string */
    res_string = realloc( res_string, strlen(res_string)  + 1);

    return res_string;                      /* return result pointer to caller  */

}


/* ********************************************************************
    Function add_args_script

    Add a file name or path to the -f arguments array.

    The file name may be absolute or relative.  If the file name does
    not have an extension (no '.' in basename string), then the default
    extension is appended.  Conversion to an absolute path, remaining
    wildcard expansion, and existence testing happen in another routine
    after all arguments have been processed.

    The caller's string may or may not be in malloc'd storage.  It is
    the caller's responsibility to free the string provided by the
    caller.

    Note that any wildcards in the command line may or may not have
    been expanded by either the shell (UNIX-like systems) or by the
    c runtime (Windows systems) before main() sees them.  If wildcards
    are not expanded, it is because the files did not exist, and
    another routine here will attempt to expand simple file names
    relative to the test scripts directory.
*/
void add_args_script( char * filename, const char * option_name )
{
                                    /* does argument have extension?    */
    if ( has_extension( filename)   /* ...or is default extension null? */
            || test_script_ext[ 0 ] == '\0' )
                                /* ..yes, do not append default ext     */
        addto_string_array( &args_scripts, strdup( filename ) );
    else                        /* ..no, append default extension       */
        addto_string_array( &args_scripts,
                concat_strings( filename, ".", test_script_ext, NULL ));

    return;
}


/* ********************************************************************
    Function add_load_module

    Add a test script file name to the loadable module array.

    The file name may be absolute or relative.  If the file name does
    not have an extension (no '.' in basename string), then the default
    extension is appended.  Existence and conversion to absolute path
    happen in another routine after all arguments have been processed.
*/
void add_load_module( char * loadmodname, const char * option_name )
{
    char * loadmod_suffixed;    /* load module name with suffix         */
    char * suffix_start;        /* start of any suffix in name          */

                                /* does load module name have a correct */
                                /* loadable module suffix for platform? */
    if ( ( suffix_start = strrchr( loadmodname, '.' ) )
            && !strcmp( suffix_start, LOADMOD_SUFFIX) )
                                /* ..yes, do not append a suffix        */
        addto_string_array( &loadmod, strdup( loadmodname ) );
    else                        /* ..no, append load module suffix      */
    {
        loadmod_suffixed = concat_strings( loadmodname, LOADMOD_SUFFIX, NULL );
        addto_string_array( &loadmod, loadmod_suffixed );
    }
    return;
}


/* ********************************************************************
    Function add_test_script

    Add a test script file name or path to the test script array.

    The file name may be absolute or relative.  If the file name does
    not have an extension (no '.' in basename string), then the default
    extension is appended.  Existence and conversion to absolute path
    happen in another routine after all arguments have been processed.

    The caller's string may or may not be in malloc'd storage.  It is
    the caller's responsibility to free the string provided by the
    caller.

    Note that any wildcard file names in the command line have been
    expanded by either the shell (UNIX-like systems) or by the c runtime
    (Windows systems) before main() sees them.
*/
void add_test_script( char * filename, const char * option_name )
{
                                    /* does test script have extension? */
    if ( has_extension( filename)   /* ...or is default extension null? */
            || test_script_ext[ 0 ] == '\0' )
                                /* ..yes, do not append default ext     */
        addto_string_array( &test_scripts, strdup( filename ) );
    else                        /* ..no, append default extension       */
        addto_string_array( &test_scripts,
                concat_strings( filename, ".", test_script_ext, NULL ));

    return;
}


/* ********************************************************************
    Function add_varval_pair

    Add a variable=value pair to the varval_pair array.

    Exactly one equals sign must exist between two strings, but the
    strings are not otherwise edited.  The only exception is -v quiet,
    which does not require a "=value" bit.

    "platform" may not be coded on the left side of the "=" sign.

    If -v ptrsize=n is coded, this is noted because there is no need
    to figure it out from config.h later.

    return codes:
    0  - Valid pair, or single value "quiet"
    -1 - no equals sign, no not a var=val pair
    -2 - attempt to set platform= to anything.

*/
int add_varval_pair( char * varvalpair, const char * option_name, int allow_platform )
{
    char * equals;      /* location of equals sign in var=val pair      */

    if ( !( equals = strchr( varvalpair, '=' ) ) )   /* equals sign?    */
    {                   /* process -v quiet or diagnose invalid -v opt  */
        if ( !strcmp( varvalpair, QUIET_NAME ) )
        {
            redtest_quiet = 1;
            return 0;
        }
        else
        {
            fprintf( stderr, "%s value \"%s\" is not in the form variable=value\n",
                    option_name, varvalpair );
            return -1;
        }
    }

                        /* at least one equals sign.  Check for another */
    if ( equals != strrchr( varvalpair, '=' ) ) /* more than one?       */
    {                   /* ..yes, var=val=whatever not allowed          */
        fprintf( stderr, "%s value \"%s\" is not in the form variable=value\n",
                option_name, varvalpair );
        return -1;
    }

                        /* Only one equals.  Check for platform         */
                        /* and that caller has disallowed platform      */
    if ( !( allow_platform
            || strncmp( varvalpair, PLATFORM_NAME, equals - varvalpair ) ) )

    {                   /* ..yes, setting platform= not allowed         */
        fprintf( stderr, "%s value \"%s\" cannot set \"platform\" variable\n",
                option_name, varvalpair );
        return -2;
    }

                        /* Only one equals.  Check for ptrsize          */
    if ( !strncmp( varvalpair, PTRSIZE_NAME, equals - varvalpair ) )
        ptrsize_found = 1;      /* ..yes, set flag for later            */

    addto_string_array( &varval, strdup( varvalpair ) );

    return 0;
}


/* ********************************************************************
    Function check_arg_dir

    Test a string to see if it is an existing directory.  If not, issue an error
    message.  Otherwise:
    1. Update the directory pointer with the new valid directory name.
    2. Convert the directory to an absolute path.

    Arguments:
    - Absolute or relative directory name to be validated.
    - Pointer to a pointer to a malloc'd string containing the current
      result directory.  This is free()'d if not NULL.
    Returns:
    - result string pointer set to malloc'd string containing the
      absolute path to directory if valid, or NULL.
    - return code zero if directory valid, 1 otherwise.
    - Message on stderr if directory is invalid.
*/
int check_arg_dir( char * dirname, char ** result_dir, const char * option_name )
{
    struct stat fst;            /* for stat call                        */

    free( *result_dir );        /* Free prior directory if present      */
    *result_dir = NULL;         /* NULL the pointer to free()'d string  */

    if ( stat( dirname, &fst )      /* non-existent or non-dir path?    */
            || !S_ISDIR( fst.st_mode ) )
                                /* ..yes, msg on stderr, NULL result     */
        fprintf( stderr, "%s directory \"%s\" does not exist\n",
                option_name, dirname );
    else                        /* ..yes, path exists and is directory  */
                                /*  convert to absolute path            */
        *result_dir = GET_REALPATH( dirname );

    return !*result_dir;
}


/* ********************************************************************
    Function check_arg_hercexe

    Test a string to see if it is either a path to the Hercules
    executable or a directory that contains the default executeable
    hercules.exe.  If not, issue an error message.  Otherwise:
    1. Update the executable pointer with the new valid executable path.
    2. Convert the path to an absolute path.

    Arguments:
    - Absolute or relative executable name or directory to be validated.
    - Pointer to a pointer to a malloc'd string containing the current
      result directory.  This is free()'d if not NULL.
    Process:
    1. Test the string as provided to see if it exists.
    2. If it does, see if it is a regular file or a directory.
    3. If a file, see if it is executable.
      a. If executable, convert to absolute path, pass back to caller,
         and return 0.
      b. If not, error message, NULL result, and return 1.
    4. If a directory, append the default executable name (based on
         platform) and see if that exists and is executable.
    Returns:
    - result string pointer set to malloc'd string containing the
      absolute path to the Hercules executable if valid, or NULL.
    - return code zero if path is valid, 1 otherwise.
    - Message on stderr if the executable path is invalid.
*/
int check_arg_hercexe( char * pathname, char ** result_path, const char * option_name )
{
    char * test_path;           /* working path under test              */
    char * save_test_path;      /* ..prior working path under test      */
    int rc = 0;                 /* tentative return code                */
    int dir_limit = 3;          /* nr. times to append exe name to path */
    struct stat fst;            /* for stat call                        */

    free( *result_path );       /* Free prior path if present           */
    *result_path = NULL;        /* NULL the pointer to free()'d string  */
    test_path = strdup( pathname ); /* Start with caller path           */

    do
    {
        if ( stat(test_path, &fst) )     /* does path exist...          */
        {                       /* ..no, error message and exit         */
            fprintf( stderr, "%s \"%s\" does not exist.\n",
                    option_name, test_path );
            rc = 1;            /* indicate failure                      */
            break;
        }

        if ( S_ISDIR( fst.st_mode ) )   /* is it a directory?           */
        {                       /* ..yes, append executable name        */
            save_test_path = test_path; /* save current test path       */
                                /* append executable name to test path  */
            if ( test_path[ strlen( test_path ) - 1] == PATH_SEPC )
                test_path = concat_strings( save_test_path, HERCULES_EXE, NULL );
            else
                test_path = concat_strings( save_test_path, PATH_SEPS, HERCULES_EXE, NULL );
            free( save_test_path ); /* free now-old test path           */
            if ( --dir_limit <= 0 )
            {
                rc = 1;
                break;
            }
            continue;           /* test updated path                    */
        }
                                /* test_path exists and is not a dir.   */
                                /* check if executable regular file     */
        if ( S_ISREG( fst.st_mode )     /* is it a regular file         */
                &&              /* ...and executable                    */
                ( fst.st_mode & ( S_IXUSR | S_IXGRP | S_IXOTH ) ) )
            break;              /* ..yes, success, we are done          */

                                /* ..no, message and return error       */
        fprintf( stderr, "%s \"%s\" is not executable\n",
                option_name, test_path );
        rc = 1;             /* indicate failure                         */

    } while( rc == 0 );         /* test until a failure return code     */

    if ( rc == 0 )              /* does path exist...           */
        *result_path = GET_REALPATH( test_path );

    free( test_path );          /* free test path string area           */
    return rc;
}


/* ********************************************************************

    function get_exepath(const char * cmdline) - get executable path

    Return a malloc'd string pointer containing the name of the
    directory containing the herctest executable that is being run.

    Three versions exist.  For Windows, the pointer _pgmptr is used to
    create a malloc'd copy of the executable path.  For macOS, the
    target system-specific API is used to retrieve the name.  For
    UNIX-like systems, argv[0] is interpreted against the current
    directory if it is a relative with one or more path separators,
    used as is if absolute, and interpreted against the PATH variable
    if just a basename exists.

    N.B., the returned char string is malloc'd by each version of this
    routine and must be free'd by the caller.

*/
#if defined(_WIN32)

/* The Windows variable _pgmptr points to the full path name of the     */
/* executable.  Unfortunately, before it can be returned, we must strip */
/* the file name from it.  Fortunately, this is not difficult.          */
int get_exepath(const char* cmdline)
{
    char * program_path;    /* pointer to absolute executable path      */
    char * drive;           /* Drive letter from _splitpath             */
    char * dirpath;         /* directory path from _splitpath           */
    char * progname;        /* executable name from _splitpath          */
    int    rc = 0;          /* rc from _get_pgmptr or _splitpath        */

    /* Microsoft reports that _pgmptr has been deprecated and replaced  */
    /* with function _get_pgmptr, which returns the absolute path of    */
    /* the executable.  But there is limited information on the first   */
    /* release of Windows to support _get_pgmptr, so we cannot do       */
    /* preprocessor code to determine when the the non-deprecated       */
    /* interface is available.  I did find a third-party site that      */
    /* reports that _get_pgmptr is available as of Windows 7, so we     */
    /* code for _get_pgmptr on Windows 7 and above.                     */

#if defined(USE_GET_PGMPTR)
    rc = _get_pgmptr( &program_path );
#else
    program_path = _pgmptr;
#endif

    if ( !rc )
    {                       /* Allocate strings for drive, directory,   */
                            /* ...and program name.  All must be        */
                            /* ...shorter than the path, so that is     */
                            /* ...we shall allocate.                    */
        drive = (char *) malloc( strlen( program_path ) );
        dirpath = (char *) malloc( strlen( program_path ) );
        progname = (char *) malloc( strlen( program_path ) );

        _splitpath( _pgmptr, drive, dirpath, progname, NULL );
        dir_herctest = concat_strings( drive, dirpath, NULL );
        name_herctest = strdup( progname );

        free( drive );      /* Free local strings                       */
        free( dirpath );
        free( progname );
    }

    return rc;              /* return drive and directory               */
}


#elif defined(__APPLE__)

int get_exepath( const char* cmdline )
{
    char * candidatepath;   /* path returned by _NSGetExecutablePath    */
    char * resultpath;      /* Actual path in malloc'd space after      */
                            /* realpath(), or NULL if unable to         */
                            /* determine the executable path.           */
    char * workpath;        /* dup of result path for dirname, basename */
    uint32_t pathlen = 0;   /* buffer size to _NSGetExecutablePath      */
                            /* ...updated on first call to length of    */
                            /* ...buffer needed for executable path     */

    int rc;                 /* Length of path, or zero if no path       */

    resultpath = NULL;      /*  presume failure for the nonce           */

    rc = _NSGetExecutablePath(candidatepath, &pathlen);
                            /* get right-sized space for path           */
    candidatepath = (char *) malloc( pathlen );
    rc = _NSGetExecutablePath(candidatepath, &pathlen);

    if ( !rc )              /* rc = 0 means we got a path               */
    {
        resultpath = realpath(candidatepath, NULL);
        free( candidatepath );
        workpath = strdup( resultpath );            /* dup for basename */
        dir_herctest = strdup( dirname( resultpath ) ); /* save direct. */
        name_herctest = strdup( basename( workpath ) ); /* save fname   */
        free( resultpath );
        free( workpath );
    }

    return rc;

}

#else    /*  !defined(_WIN32) && !defined(__APPLE__)   */
/* ********************************************************************
    UNIX-like system but not macOS/OS X.  Such lack an API to retrieve
    the executable path name.  So this function does what a shell would
    do: interpret the command line relative to either the current
    working directory or the PATH environment variable.  This is not
    perfect, but it will have to do.

    Note that the current working directory is not an automatic option
    as it is in Windows.  To execute a program from the CWD, one must
    either have "." in the $PATH variable or use ./<exename>.  The
    later includes a slash and is therefore considered relative to
    the current working directory.
*/
int get_exepath(const char * cmdline)
{
    char * candidatepath;   /* Cannonical candidate absolute path of    */
                            /* ...executable.                           */
    char * candrealpath;    /* candidate executable after realpath()    */
    char * workpath;        /* work path for dirname / basename         */

    if ( strchr( cmdline, PATH_SEPC ) ) /* is command an abs path       */
                                /* ...or relative to CWD?               */
    {                           /* ..yes, cannonicalize and test for    */
                                /*        executable                    */
        candrealpath = realpath(cmdline, NULL );

        if (ACCESS( candrealpath, X_OK ) )  /* nz means file not an executable     */
        {
            dir_herctest = NULL;    /* no directory found               */
            name_herctest = NULL;   /* no file name found               */
            free( candrealpath );   /* free invalid path                */
            return 1;               /* Not a valid path to executable   */
        }
    }

    else                        /* Just a program name on command line  */
    {
        char * path_copy;       /* copy of path string from environment */
        char * pathdir;         /* Pointer to one dir within PATH       */

        /* Note: getenv returns a pointer that is within the            */
        /* environment area.  Do not change the string pointed to by    */
        /* the result of getenv().                                      */
        path_copy = strdup( getenv("PATH") ); /* copy $PATH string      */

        /* point to first directory named in path; NULL on this first   */
        /* call means there are no directories in the path string       */

                                            /* get first PATH element   */
        if ( ( pathdir = strtok( path_copy, ":" ) ) )
            do
            {
                                /* construct candidate path             */
                candidatepath = concat_strings( pathdir, PATH_SEPS, cmdline, NULL );
                                /* canonicalize and verify existence    */
                candrealpath = realpath( candidatepath, NULL );
                free( candidatepath );  /* free candidate path              */
                if ( !candrealpath )    /* did the path exist?              */
                    continue;           /* ..No, NULL returned, try next    */

                /* File exists.  See if it is an executable.  We do not */
                /* care what kind of executable.  Systems using         */
                /* GNU-libtool use a shell script as a wrapper for the  */
                /* executable.                                          */
                if (!(ACCESS(candrealpath, X_OK)))  /* Executable?      */
                    break;              /* ..yes, our work is done.     */
                free( candrealpath );   /* ..no, free the string, NULL  */
                candrealpath = NULL;    /* ...the candidate, continue   */
            } while( ( pathdir = strtok( NULL, ":" ) ) );

    }

    /* candrealpath has either the executable path or NULL              */

    if ( candrealpath )
    {
        candidatepath = strdup( candrealpath );
        dir_herctest = strdup( dirname( candrealpath ) );
        name_herctest = strdup( basename( candidatepath ) );
        free( candidatepath );
        free( candrealpath );
    }
    else
        return 2;           /* return failed to get dir/exe name        */

    return 0;               /* return "all is well"                     */

}
#endif


/* ********************************************************************

    function get_dirname(const char * fullpath ) - get directory name

    Return a malloc'd string pointer containing the directory portion
    of the path provided.  This means removing the last bit of the path,
    even if the last bit is also a directory.

    Two versions exist.  For Windows, the _splitpath function is used
    to break the path into its component parts.  The last bit is always
    assumed to be the file name with optional extension, so concatenating
    the drive and directory strings from _splitpath does a dirname
    nicely.

    Two versions exist.  On UNIX-like systems, the caller's pathname is
    copied because dirname may alter the string.  The dirname system-
    provided function is used to get the directory name, and this is
    duplicated into malloc'd storage.

    N.B., the char string returned by either version of get_dirname is
    malloc'd and must be free'd by the caller.

*/
#if defined(_WIN32)

/* Use _splitpath() to remove the last item (file name with optional    */
/* extension).  The last item is always assumed to be a file name       */
/* it happens to be a server name from an UNC path ("\\server\").       */
char * get_dirname(const char* fullpath )
{
    char * drive;           /* Drive letter from _splitpath             */
    char * dirpath;         /* directory path from _splitpath           */
    char * result_dirname;  /* resulting drive and directory            */

    drive = (char *) malloc( strlen( fullpath ) );  /* alloc drive and  */
    dirpath = (char *) malloc( strlen( fullpath ) ); /* dir space       */

    _splitpath( fullpath, drive, dirpath, NULL, NULL );
    result_dirname = concat_strings( drive, dirpath, NULL );

    free( drive );
    free( dirpath);

    return result_dirname;  /* return drive and directory               */
}


#else    /*  !defined(_WIN32)   */
/* ********************************************************************
    UNIX-like system. Use the system-provided dirname function.  Because
    dirname may alter the caller-provided path and/or return a pointer
    to statically-allocated storage, we do the following:
    1. strdup the caller string so that the caller's string is not
        altered.
    2. strdup the returned string for return to the caller.
    3. free the copy of the caller string.
    This approach preserves the caller string, protects against future
    alteration of a pointer to static storage, and ensures that the
    pointer returned to the caller can be free'd safely.
*/
char * get_dirname( const char* fullpath )
{
    char * dup_fullpath;            /* duplicate of caller's fullpath   */
    char * dirname_return;          /* pointer returned by dirname      */
    char * result_dir;              /* resulting directory of fullpath  */

    dup_fullpath = strdup( fullpath );      /* copy caller's path       */
    dirname_return = dirname( dup_fullpath );   /* get directory part   */
    result_dir = strdup( dirname_return );      /* dup dirname result   */
    free( dup_fullpath );           /* free the dup of caller's path    */
    return result_dir;              /* return pointer to malloc'd path  */

}
#endif


/* ********************************************************************
    Function get_ptrsize

    Scan config.h for #define SIZEOF_SIZE_T; when found, use the value
    defined to add -v ptrsize=<value> to the varval array.  Return 0 if
    the addition was done and 1 if something prevented determination
    of ptrsize.

    Search for the config.h file in the Hercules executable directory
    on the assumption that such is the build directory.  If there is
    no Hercules executable directory, return 1 but do not issue a
    message.

    Block comments such as this and c++ // comments are ignored.
*/
int get_ptrsize()
{
    char * config_h_path;   /* path of config.h file                    */
    char * save_path;       /* multi-purpose string pointer             */
    char * ptrsize_set;     /* string ptrsize=? for addition to varval  */
    char * ptrsize;         /* string contaning SIZEOF_SIZE_T value     */
                            /* ...for now, this is a single digit.  But */
                            /* ...who knows the future?                 */
    char   config_line[ 256 ];  /* one line of input from config.h      */
    char * config_line_ptr; /* pointer to current char in line          */

    int    line_nr = 0;     /* current line number in config.h          */

    FILE * fd;              /* descriptor for config.h file I/O         */

    if ( !dir_hercules )    /* executable directory located?            */
        return 1;           /* ..no, nothing to be done.                */

    save_path = concat_strings( dir_hercules, PATH_SEPS, CONFIG_H_NAME, NULL );
    config_h_path = GET_REALPATH( save_path );
    free( save_path );

    if ( !config_h_path )
    {
        fprintf( stderr, "File \"%s\" not found in \"%s\"\n",
            CONFIG_H_NAME, dir_hercules );
        return 1;           /* return "failure" to caller               */
    }

    /* config.h exists.  We could stat/access the file for diagnostics, */
    /* but just open the file.  That will tell us what we need.         */
    fd = fopen( config_h_path, "r" );   /* open for reading.            */
    if ( !fd )              /* did open fail?                           */
    {                       /* ..yes, provide a diagnostic              */
        if ( errno == EACCES )
            fprintf( stderr, "Cannot access (permissions) \"%s\" in \"%s\"\n",
                    CONFIG_H_NAME, dir_hercules );
        else
            fprintf( stderr, "Error %d opening \"%s\" in \"%s\"\n",
                    errno, CONFIG_H_NAME, dir_hercules );
        free( config_h_path );
        return 1;           /* return "failure" to caller               */
    }

    /* Anyone looking for a parser here will be profoundly disappointed */
    /* because that is not what this is.                                */
    /*                                                                  */
    /* This code looks for                                              */
    /*                                                                  */
    /*      ^[ ]*#[ ]*define [ ]*SIZEOF_SIZE_T [ ]*(.*)$                */
    /*                                                                  */
    /* with the contents of (.*) used as the value for ptrsize=         */
    /* ...and that's all that it does.                                  */
    while ( !feof( fd ) )
    {
        config_line_ptr = fgets( config_line, sizeof( config_line ), fd );
        if ( !config_line_ptr )     /* did we get another line?         */
            break;                  /* ..no, we are done                */

        line_nr++;                  /* increment line number            */

        while ( *config_line_ptr == ' ' )  /* skip leading blanks       */
            config_line_ptr++;

        if ( *config_line_ptr++ != '#' )
            continue;

        while ( *config_line_ptr == ' ' )   /* skip blanks after '#'    */
            config_line_ptr++;

        if ( strncmp( config_line_ptr, "define ", 7 ) )
            continue;

        config_line_ptr += 7;

        while ( *config_line_ptr == ' ' )   /* skip blks after "define"    */
            config_line_ptr++;

        if ( strncmp( config_line_ptr, PTRSIZE_SOURCE, strlen( PTRSIZE_SOURCE ) ) )
            continue;

        config_line_ptr += 13;

        while ( *config_line_ptr == ' ' )   /* skip blks after "SIZEOF..."    */
            config_line_ptr++;

        ptrsize = config_line_ptr;      /* start of SIZEOF_SIZE_T value */
        while ( *config_line_ptr != ' ' /* look for end of value        */
                && *config_line_ptr != '\0' )
            config_line_ptr++;

                                        /* if the value includes a      */
                                        /* ...line end, strip it.       */
        if ( *( config_line_ptr - 1 ) == '\n'   /* UNIX-like or         */
                || *( config_line_ptr - 1 ) == '\r' )   /* ...Windows   */
            config_line_ptr--;          /* ..yes, do not include it     */

        *config_line_ptr = '\0';        /* terminate the value string   */

        if ( *ptrsize == '\0' )         /* Null string for value?   */
        {
            fprintf( stderr, "No value provided for %s in %s\n",
                    PTRSIZE_SOURCE, config_h_path );
            fprintf( stderr, "%s line %d: %s\n",
                    CONFIG_H_NAME, line_nr, config_line);
            break;
        }
        else
        {                               /* try to convert to numeric    */
            strtol( ptrsize, &config_line_ptr, 0 );
            if ( *config_line_ptr )    /* chars left over, not numeric */
            {
                fprintf( stderr, "Non-numeric value \"%s\" provided for PTRSIZE_SOURCE in %s\n",
                        ptrsize, config_h_path );
                fprintf( stderr, "%s line %d: %s\n",
                        CONFIG_H_NAME, line_nr, config_line);
                break;
            }
        }

        /* create ptrsize=<value> and add it to varval array            */
        ptrsize_set = concat_strings( PTRSIZE_NAME, "=", ptrsize, NULL);
        add_varval_pair( ptrsize_set, "Setting ptrsize from SIZEOF_SIZE_T,", 0 );
        free( ptrsize_set );
        break;                      /* done scanning config.h           */

    }


    if ( feof( fd ) && !ptrsize_found )
        fprintf( stderr, "%s not found in %s, needed to set ptrsize\n",
                PTRSIZE_SOURCE, config_h_path );

    fclose( fd );           /* close config.h                           */
    free( config_h_path );  /* and free path name                       */

    /* add_varval_pair sets ptrsize_found when it is added to the       */
    /* varval array.  We use that flag to set the return code           */

    return !ptrsize_found;
}

/* ********************************************************************
    Function has_extension

    Return 1 if the filename passed has an extension, 0 otherwise.
    Filename may be absolute or relative.  Extensions on directory
    portions of the filename are not relevant to this test and are
    ignored.

    This routine comes in two versions, Windows and UNIX-like/macOS.
*/
#if defined(_WIN32)
int has_extension( char * filename )    /* Windows version              */
{
    char ext[_MAX_EXT];

    /* _splitpath returns a null string for ext if the pathname has     */
    /* no extension.  Window documentation says a full pathname is      */
    /* required for input, but that is not the same thing as an         */
    /* absolute path name.                                              */

    _splitpath( filename, NULL, NULL, NULL, ext );

    return *ext != '\0';

}
#else
int has_extension( char * filename )    /* UNIX-like, OS X, and macOS   */
{
    int rc;                     /* return code                          */
    char * save_fname;          /* saved filename; basename() may       */
                                /* corrupt the string it is called with */

    save_fname = strdup( filename );  /* copy for basename fn           */
                                /* does file name have an extension?    */
    rc = !!strchr( basename( save_fname ), '.' );

    free( save_fname );
    return rc;

}
#endif


/* ******************************************************************** */
#if defined(_WIN32)             /* start of Windows wrappers            */
/* ******************************************************************** */

/* ********************************************************************

    function win_glob - Windows version of limited-function glob()

    This routine implements a subset of the functionality provided in
    the glob() function available in UNIX-like systems.  No attempt is
    made to completely emulate the glob() function in Linux, much less
    that available in the BSD glob.

    A struct compatible with that defined in glob.h is populated with
    paths that match the provided pattern, and a non-zero error code
    indicates failure.  The calling routine just checks whether one or
    more paths were returned and treats zero paths as "not found."
*/

/* ******************************************************************** */
/* ---   start of code adapted from Microsoft ---                       */
/* ******************************************************************** */
/*  The code in the Windows version of this routine is adapted from the */
/*  following Microsoft page.  Modifications are subject to the         */
/*  copyright for this compilation unit; copyright of the original      */
/*  work is disclaimed in favor of the rights of its author.            */
/*                                                                      */
/*  https://docs.microsoft.com/en-us/windows/desktop/FileIO/listing-the-files-in-a-directory    */
/*                                                                      */
/*  Because this routine is compiled only under Windows, the wonky (at  */
/*  least for developers of code for UNIX-like systems) type macros are */
/*  mostly retained to ensure portability to newer versions of Windows. */
/*                                                                      */
/*  This routine walks the test script directory using the pathname     */
/*  provided by the caller and adds all non-directory entries to the    */
/*  test script array.                                                  */

char * win_glob_error();    /* collect Windows error information        */

int win_glob(               /* Windows version of UNIX-like glob()      */
        const char * path,  /* pattern to be matched                    */
        int flags,          /* processing flags (not impl.)             */
	    int (*errfunct)(const char *, int), /* error fn (not impl.)     */
        glob_t * paths )    /* returned paths array                     */

{

    size_t paths_alloc = 0; /* count of string ptrs alloc'd in paths    */
    char * msg;             /* space for error message if any           */
    char * path_to_add;     /* absolute path name to be added           */
    int    rc = 0;          /* return code, zero means all good         */

    WIN32_FIND_DATA ffd;    /* Directory entry data                     */
    HANDLE hFind = INVALID_HANDLE_VALUE;    /* handle for search oper.  */
    DWORD dwError=0;        /* Error indication                         */

                            /* initialize caller's result array         */
    paths->gl_pathc = 0;    /* Count of total paths so far              */
    paths->gl_pathv = NULL; /* List of paths matching pattern           */

                            /* get first match                          */
    hFind = FindFirstFile( path, &ffd );

    if ( INVALID_HANDLE_VALUE != hFind )
    {
        /* At least one match.  Retrieve one at a time the file names   */
        /* that match search_path.  Add those that are not directories  */
        /* to the glob result array.  Note that wildcards with a fixed  */
        /* extension such as "*.tst" will also find things with longer  */
        /* matching extensions such as <fname>.tstsp.  This is how      */
        /* Windows glob expansion works, and we will not improve on     *
        /* this behavior.                                               */
        do
        {
            if ( !( ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                path_to_add = strdup( ffd.cFileName );
                if ( paths->gl_pathc >= paths_alloc )
                    paths->gl_pathv = (char **) realloc(
                            paths->gl_pathv,
                            sizeof( *paths->gl_pathv ) * ( paths_alloc += WIN_GLOB_PATH_ALLOC ) );
                paths->gl_pathv[ paths->gl_pathc++ ] = path_to_add;
            }
        }
        while ( FindNextFile( hFind, &ffd ) != 0 );

        dwError = GetLastError();
        if (dwError != ERROR_NO_MORE_FILES)   /* if not end of files,   */
        {                           /* ..retrieve system error message  */
                                    /* ..text for the last error code   */
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_SYSTEM
                        | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,               /* message source; ignored based on flags   */
                dwError,            /* error code to be formatted               */
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  /* NLS              */
                (LPTSTR) &msg,      /* allocate buffer, store address here      */
                0,                  /* buffer size, ignored, buffer allocated   */
                NULL );             /* No inserts, so no arguments.             */

            fprintf( stderr, "Enumeration of test scripts in \"%s\" failed with rc=%dll\n",
                    dir_test_scripts, dwError );
            fprintf( stderr, "%s", msg );

            LocalFree( (HLOCAL) msg );   /* free error message string       */
                                /* ..LocalFree required by FormatMessage    */
            rc++;               /* indicate errors occured                  */
        }
        dwError = FindClose(hFind);

    }

    /* append a NULL to the array of string pointers.  Then trim the    */
    /* string array to exact size required for the number of paths      */
    if ( paths->gl_pathc >= paths_alloc )   /* Room for the NULL        */
    {                       /* ..no, add one more slot                  */
        paths->gl_pathv = 
            (char **) realloc( paths->gl_pathv,
            sizeof( *paths->gl_pathv ) * ( paths_alloc += 1 ) );
    }
    else if ( paths->gl_pathc < paths_alloc - 1 )
    {
        paths_alloc = paths->gl_pathc + 1;
        paths->gl_pathv = (char **) realloc(
                paths->gl_pathv,
                sizeof( *paths->gl_pathv ) * paths_alloc );

    }

    paths->gl_pathv[ paths->gl_pathc ] = NULL;

    if ( !dwError )
    {
        dwError = GetLastError();
        if ( !(dwError == ERROR_NO_MORE_FILES 
                || dwError == ERROR_FILE_NOT_FOUND) )
        {                           /* ..retrieve system error message  */
                                    /* ..text for the last error code   */
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_SYSTEM
                        | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,               /* message source; ignored based on flags   */
                dwError,            /* error code to be formatted               */
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  /* NLS              */
                (LPTSTR) &msg,      /* allocate buffer, store address here      */
                0,                  /* buffer size, ignored, buffer allocated   */
                NULL );             /* No inserts, so no arguments.             */

            fprintf( stderr, "Close of find handle \"%s\" failed with rc=%dll\n",
                    dir_test_scripts, dwError );
            fprintf( stderr, "%s", msg );

            LocalFree( (HLOCAL) msg );   /* free error message string       */
                                /* ..LocalFree required by FormatMessage    */
        }
    }

    return rc;
}


void win_globfree( glob_t * paths )
{
    size_t i;

    if ( paths->gl_pathv )
    {
        for ( i = 0; i < paths->gl_pathc; i++ )
        {
            free( paths->gl_pathv[ i ] );
            paths->gl_pathv[ i ] = NULL;
        }
        free( paths->gl_pathv );
        paths->gl_pathv = NULL;
    }

    return;
}
/* ******************************************************************** */
/* ---   end of code adapted from Microsoft ---                         */
/* ******************************************************************** */


/* ********************************************************************

    function char * win_realpath( const char * relpath )

    Windows wrapper function for UNIX-like realpath().

    The closest Windows equivalent function, _fullpath, does not return
    NULL if the path does not exist.

    This wrapper calls _fullpath(), and then stat's the absolute path
    to see that it exists.  The path must be either a directory or a
    regular file, the only two file system entities herctest cares
    about.

    Note: the _fullpath function treats '\' and '/' in the input string
    as path separators and canonicalizes them into '\'.  Further, an
    input string containing mixed path separators, including adjacent
    mixed separators, are handled without issue.  So...

    "c:/comman/github//test\/sample" ==> "c:\comman\github\test\sample"

*/
char * win_realpath( const char * relpath )
{
    char * result_path;     /* returned abs. path, malloc'd, or NULL    */
    struct stat fst;        /* for stat call on absolute path           */

    result_path = _fullpath( NULL, relpath, 0 );

    if ( !stat( result_path, &fst )     /* does file exist AND is it    */
            &&  ( S_ISDIR( fst.st_mode )  /* ...a file OR a directory?  */
                  || S_ISREG( fst.st_mode ) ) )
        return result_path;     /* ..yes, return absolute path name     */

    free( result_path );    /* release result path storage              */
    return NULL;

}



/* ******************************************************************** */
#endif                      /* End of Windows wrappers                  */
/* ******************************************************************** */



/* ********************************************************************
    Display summary help for this command.  Summary help is displayed
    when an invalid option is provided on the commmand line.
*/
void short_help()
{

    char * script_pad  = "  ";

    fprintf( stdout, "\n" );
    fprintf( stdout, "%s", name_herctest );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   - run Hercules to process one or more test scripts and analyze results\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   -d <testdir_path>\n" );
    fprintf( stdout, "   -e <default_extension>\n" );
    fprintf( stdout, "   -f <test_script> [ <test_script> ... ]\n" );
    fprintf( stdout, "   -h <herc_bindir_path>\n" );
    fprintf( stdout, "   -l <loadable_module> [ <loadable_module> ... ]\n" );
    fprintf( stdout, "   -p <loadmod_path>\n" );
    fprintf( stdout, "   -q           # run tests quietly\n" );
    fprintf( stdout, "   -r <repeat_count>\n" );
    fprintf( stdout, "   -t <timeout_adjustment_factor>\n" );
    fprintf( stdout, "   -v <redtest_var>=<redtest_varval>\n" );
    fprintf( stdout, "   -w <workfile_name>\n" );
    fprintf( stdout, "   -x           # do not quit Hercules at end of tests\n" );
    fprintf( stdout, "   --help       # display this help and exit.\n" );
    fprintf( stdout, "   --helplong   # display verbose help and exit.\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "Options -e, -f, and -v may be repeated." );
    fprintf( stdout, "\n" );

    return;

}

/*
********************************************************************
Display detailed help for this program.  Detailed help is only
displayed when requested.

Derived from John P. Hartmann's runtest shell script, which he
placed in the public domain on 5 Oct 2015.

********************************************************************
*/

void long_help()
{
    fprintf( stdout, "\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "-d <testdir_path>\n" );
    fprintf( stdout, "   Specify the path to the test directory.  The default is the \"%s\"\n",
                    TESTS_SUBDIR );
    fprintf( stdout, "   subdirectory of the directory that herctest is run from (not the\n" );
    fprintf( stdout, "   working directory), perhaps ../hyperion/tests.  <path> may be\n" );
    fprintf( stdout, "   absolute or relative to the current working directory.  If -d is\n" );
    fprintf( stdout, "   specified multiple times, the last one is used.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-e <default_extension>\n" );
    fprintf( stdout, "   Specify the extension for test scripts specified by -f that do not\n" );
    fprintf( stdout, "   have an extension.  \".tst\" is the initial default value for -e.\n" );
    fprintf( stdout, "   The current value of the -e flag is active for all test scripts\n" );
    fprintf( stdout, "   named in -f flags until the next -e flag.  For example:\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "      runtest.rexx -f file1 file2.txt -e sptst -f file3 file4\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   Will run the following test scripts:\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "      file1.tst file2.txt file3.sptst file4.sptst\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   If you do not include the \".\" at the beginning of the extension,\n" );
    fprintf( stdout, "   it will be added for you.  -e may be specified as many times as\n" );
    fprintf( stdout, "   needed.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-f <test_script> [ <test_script> ...]\n" );
    fprintf( stdout, "   Specify the the name of a test script.  More than one script name\n" );
    fprintf( stdout, "   may follow -f, and multiple -f flags are accepted.  If an extension\n" );
    fprintf( stdout, "   is omitted, the extension specified in the most recent -e option,\n" );
    fprintf( stdout, "   is used.  If no -e option preceeds the -f, the extension \".tst\" is\n" );
    fprintf( stdout, "   used.  Wildcards are allowed.  \n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   Relative paths are interpreted relative to the current working directory.\n" );
    fprintf( stdout, "   Wildcards in relative path names are expanded based on the current \n" );
    fprintf( stdout, "   working directory.  \n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   If a test script name does not include any directory components and is\n" );
    fprintf( stdout, "   not found in the current working directory, the test scripts directory\n" );
    fprintf( stdout, "   will be searched for the script, and any wildcarding will be expanded\n" );
    fprintf( stdout, "   relative to the test scripts directory.\n" );
    fprintf( stdout, "\n" );
    fprintf( stdout, "   The default is \"-f  *.tst\" to run all test scripts in the test script\n" );
    fprintf( stdout, "   directory.  The current working directory is not searched when the\n" );
    fprintf( stdout, "   default is allowed for -f.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-h <herc_bindir_path>\n" );
    fprintf( stdout, "   Specify the directory that contains the Hercules executable.\n" );
    fprintf( stdout, "   If -h is specified, then the Hercules executable must exist\n" );
    fprintf( stdout, "   in that directory, and that executable will be used to run the\n" );
    fprintf( stdout, "   test scripts.  If -h is not specified and a Hercules executable\n" );
    fprintf( stdout, "   exists in the current working directory, that executable is\n" );
    fprintf( stdout, "   used.  Otherwise, the the hercules executable in the parent\n" );
    fprintf( stdout, "   of the test script directory (\"-d\" option) is used\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-l <loadable_module> [ <loadable_module> ... ]\n" );
    fprintf( stdout, "   Specify the name of a module to load dynamically into hercules.  This\n" );
    fprintf( stdout, "   is passed to Hercules.  Hercules loads module dyncrypt at start-up,\n" );
    fprintf( stdout, "   so dyncrypt cannot be specified here.  You can specify multiple -l\n" );
    fprintf( stdout, "   flags; they will be accumulated.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-p <loadmod_path>\n" );
    fprintf( stdout, "   Specify the library path for loadable modules.  If the directory\n" );
    fprintf( stdout, "   from which the Hercules executable is loaded contains a \".libs\"\n" );
    fprintf( stdout, "   subdirectory that also contains a Hercules executable, that \".libs\"\n" );
    fprintf( stdout, "   directory is the default loadable module.  Otherwise the default\n" );
    fprintf( stdout, "   loadable module path is the directory containing the Hercules\n" );
    fprintf( stdout, "   executable.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-q\n" );
    fprintf( stdout, "   Pass \"-v quiet\" to redtest.rexx to suppress details about test scripts.\n" );
    fprintf( stdout, "   -q can be specified multiple times, but the effect is the same whether\n" );
    fprintf( stdout, "   it is specified once or more than once.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-r <repeat_count>\n" );
    fprintf( stdout, "   Repeat each test script n times.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-t <timeout_adjustment_factor>\n" );
    fprintf( stdout, "   The timeout adjustment factor is passed to Hercules to increase the\n" );
    fprintf( stdout, "   amount of time a test script can run before being canceled.  The\n" );
    fprintf( stdout, "   factor is a number between 1.0 and 14.3 inclusive.  The maximum\n" );
    fprintf( stdout, "   is determined by constants coded in Hercules.  The default is 1.0.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-v <redtest_var>=<redtest_varval>\n" );
    fprintf( stdout, "-v quiet\n" );
    fprintf( stdout, "   Set a variable for redtest.rexx to a specified value, or pass the\n" );
    fprintf( stdout, "   flag \"quiet\" to reduce the number of messages generated by\n" );
    fprintf( stdout, "   redtest.rexx.  Variables set with -v are available to test scripts\n" );
    fprintf( stdout, "   when results from those scripts are analyzed by redtest.rexx.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-v ptrsize=4 | 8\n" );
    fprintf( stdout, "   Provides the size of a host system pointer to redtest.rexx.  One\n" );
    fprintf( stdout, "   current test, \"mainsize.tst,\" requires ptrsize to interpret\n" );
    fprintf( stdout, "   messages issued by Hercules to main storage size commands.\n" );
    fprintf( stdout, "   Specify 4 for a 32-bit host system and 8 for a 64-bit host system.\n" );
    fprintf( stdout, "   The default is the value of SIZEOF_SIZE_P in the config.h file\n" );
    fprintf( stdout, "   in the Hercules executable directory.  If config.h cannot be\n" );
    fprintf( stdout, "   located and -v ptrsize= is not specified, an error message is\n" );
    fprintf( stdout, "   issued and no tests are run.\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-w <workfile_name>\n" );
    fprintf( stdout, "   Specify the file name for the three work files created by this\n" );
    fprintf( stdout, "   script.  The files are:\n" );
    fprintf( stdout, "      <workfile_name>.testin - consolidated test script file\n" );
    fprintf( stdout, "      <workfile_name>.out    - Hercules log from test execution\n" );
    fprintf( stdout, "      <workfile_name>.txt    - redtest log results.name.\n" );
    fprintf( stdout, "   The file name must consist of only the characters in the POSIX\n" );
    fprintf( stdout, "   portable file name character set, namely [A-Za-z0-9\\._-] (upper\n" );
    fprintf( stdout, "   and lower case alphabetic, numeric, and period, underscore, n" );
    fprintf( stdout, "   and dash.  The default work file name is \"allTests\".\n" );
    fprintf( stdout, "\n" );

    fprintf( stdout, "-x\n" );
    fprintf( stdout, "   Do not append the quit command the composite test script.\n" );
    fprintf( stdout, "\n" );

/*
     ####  End of material from John P. Hartmann's runtest shell script.
*/
}


#if defined(_WIN32)
/* *********************************************************************
    The following is taken from FreeBSD and is subject to separate
    copyrights and licenses. Four lines were modified from the FreeBSD
    code; these are identified with c++ style comments ("//") and the
    phrase "modification for herctest.c" in standard c comments.  In
    addition, the function warnx has been neutered because we do not
    need error messages from getopt_long(), and the constants, statics,
    and #defines from getopt.h are coded above.  The definitions of the
    constants, statics, and #defines above are also subject to the
    separate copyright and license, shown below.

    Modifications are Copyright (c) 2018 Stephen R. Orso.

    Modifications are distributed under the Boost Software License,
    Version 1.0.  See accompanying file BOOST_LICENSE_1_0.txt or copy
    at http://www.boost.org/LICENSE_1_0.txt)

    More changes could have been made, but the concept here is that some
    future version of a permissively-licensed getopt_long could be
    "dropped in" with minimal changes.  Besides, getopt_long processes
    the command line arguments; how much overall performance improvement
    will one get by tweaking getopt_long?

    Note in particular that we do not define REPLACE_GETOPT.  We do not
    use getopt(), so there is no dependence on a function that does not
    exist in a Windows environment.
*/

/* ******************************************************************** */
/* ******  Start of drop-in of getopt_long() from FreeBSD source  ***** */

/*	$OpenBSD: getopt_long.c,v 1.26 2013/06/08 22:47:56 millert Exp $	*/
/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if 0
#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $";
#endif /* LIBC_SCCS and not lint */
#endif
// #include <sys/cdefs.h>           /* modification for herctest.c      */
//__FBSDID("$FreeBSD$");            /* modification for herctest.c      */

//#include <err.h>                  /* modification for herctest.c      */
#include <errno.h>
//#include <getopt.h>               /* modification for herctest.c      */
#include <stdlib.h>
#include <string.h>

#define GNU_COMPATIBLE		/* Be more compatible, configure's use us! */

#if 0				/* we prefer to keep our getopt(3) */
#define	REPLACE_GETOPT		/* use this getopt as the system getopt(3) */
#endif

#ifdef REPLACE_GETOPT
int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = '?';		/* character checked for validity */
int	optreset;		/* reset getopt */
char    *optarg;		/* argument associated with option */
#endif

#define PRINT_ERROR	((opterr) && (*options != ':'))

#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */

/* return values */
#define	BADCH		(int)'?'
#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
#define	INORDER 	(int)1

#define	EMSG		""

#ifdef GNU_COMPATIBLE
#define NO_PREFIX	(-1)
#define D_PREFIX	0
#define DD_PREFIX	1
#define W_PREFIX	2
#endif

static int getopt_internal(int, char * const *, const char *,
			   const struct option *, int *, int);
static int parse_long_options(char * const *, const char *,
			      const struct option *, int *, int, int);
static int gcd(int, int);
static void permute_args(int, int, int, char * const *);

static char *place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char illoptchar[] = "illegal option -- %c"; /* From P1003.2 */
#ifdef GNU_COMPATIBLE
static int dash_prefix = NO_PREFIX;
static const char gnuoptchar[] = "invalid option -- %c";

static const char recargstring[] = "option `%s%s' requires an argument";
static const char ambig[] = "option `%s%.*s' is ambiguous";
static const char noarg[] = "option `%s%.*s' doesn't allow an argument";
static const char illoptstring[] = "unrecognized option `%s%s'";
#else
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptstring[] = "unknown option -- %s";
#endif

/*
 * Compute the greatest common divisor of a and b.
 */
static int
gcd(int a, int b)
{
	int c;

	c = a % b;
	while (c != 0) {
		a = b;
		b = c;
		c = a % b;
	}

	return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void
permute_args(int panonopt_start, int panonopt_end, int opt_end,
	char * const *nargv)
{
	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
	char *swap;

	/*
	 * compute lengths of blocks and number and size of cycles
	 */
	nnonopts = panonopt_end - panonopt_start;
	nopts = opt_end - panonopt_end;
	ncycle = gcd(nnonopts, nopts);
	cyclelen = (opt_end - panonopt_start) / ncycle;

	for (i = 0; i < ncycle; i++) {
		cstart = panonopt_end+i;
		pos = cstart;
		for (j = 0; j < cyclelen; j++) {
			if (pos >= panonopt_end)
				pos -= nnonopts;
			else
				pos += nopts;
			swap = nargv[pos];
			/* LINTED const cast */
			((char **) nargv)[pos] = nargv[cstart];
			/* LINTED const cast */
			((char **)nargv)[cstart] = swap;
		}
	}
}

/*
 * parse_long_options --
 *	Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int
parse_long_options(char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int short_too, int flags)
{
	char *current_argv, *has_equal;
#ifdef GNU_COMPATIBLE
	char *current_dash;
#endif
	size_t current_argv_len;
	int i, match, exact_match, second_partial_match;

	current_argv = place;
#ifdef GNU_COMPATIBLE
	switch (dash_prefix) {
		case D_PREFIX:
			current_dash = "-";
			break;
		case DD_PREFIX:
			current_dash = "--";
			break;
		case W_PREFIX:
			current_dash = "-W ";
			break;
		default:
			current_dash = "";
			break;
	}
#endif
	match = -1;
	exact_match = 0;
	second_partial_match = 0;

	optind++;

	if ((has_equal = strchr(current_argv, '=')) != NULL) {
		/* argument found (--option=arg) */
		current_argv_len = has_equal - current_argv;
		has_equal++;
	} else
		current_argv_len = strlen(current_argv);

	for (i = 0; long_options[i].name; i++) {
		/* find matching long option */
		if (strncmp(current_argv, long_options[i].name,
		    current_argv_len))
			continue;

		if (strlen(long_options[i].name) == current_argv_len) {
			/* exact match */
			match = i;
			exact_match = 1;
			break;
		}
		/*
		 * If this is a known short option, don't allow
		 * a partial match of a single character.
		 */
		if (short_too && current_argv_len == 1)
			continue;

		if (match == -1)	/* first partial match */
			match = i;
		else if ((flags & FLAG_LONGONLY) ||
			 long_options[i].has_arg !=
			     long_options[match].has_arg ||
			 long_options[i].flag != long_options[match].flag ||
			 long_options[i].val != long_options[match].val)
			second_partial_match = 1;
	}
	if (!exact_match && second_partial_match) {
		/* ambiguous abbreviation */
		if (PRINT_ERROR)
			warnx(ambig,
#ifdef GNU_COMPATIBLE
			     current_dash,
#endif
			     (int)current_argv_len,
			     current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (match != -1) {		/* option found */
		if (long_options[match].has_arg == no_argument
		    && has_equal) {
			if (PRINT_ERROR)
				warnx(noarg,
#ifdef GNU_COMPATIBLE
				     current_dash,
#endif
				     (int)current_argv_len,
				     current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
#ifdef GNU_COMPATIBLE
			return (BADCH);
#else
			return (BADARG);
#endif
		}
		if (long_options[match].has_arg == required_argument ||
		    long_options[match].has_arg == optional_argument) {
			if (has_equal)
				optarg = has_equal;
			else if (long_options[match].has_arg ==
			    required_argument) {
				/*
				 * optional argument doesn't use next nargv
				 */
				optarg = nargv[optind++];
			}
		}
		if ((long_options[match].has_arg == required_argument)
		    && (optarg == NULL)) {
			/*
			 * Missing argument; leading ':' indicates no error
			 * should be generated.
			 */
			if (PRINT_ERROR)
				warnx(recargstring,
#ifdef GNU_COMPATIBLE
				    current_dash,
#endif
				    current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
			--optind;
			return (BADARG);
		}
	} else {			/* unknown option */
		if (short_too) {
			--optind;
			return (-1);
		}
		if (PRINT_ERROR)
			warnx(illoptstring,
#ifdef GNU_COMPATIBLE
			      current_dash,
#endif
			      current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (idx)
		*idx = match;
	if (long_options[match].flag) {
		*long_options[match].flag = long_options[match].val;
		return (0);
	} else
		return (long_options[match].val);
}

/*
 * getopt_internal --
 *	Parse argc/argv argument vector.  Called by user level routines.
 */
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int flags)
{
	char *oli;				/* option letter list index */
	int optchar, short_too;
	static int posixly_correct = -1;

	if (options == NULL)
		return (-1);

	/*
	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
	 * XXX using optreset.  Work around this braindamage.
	 */
	if (optind == 0)
		optind = optreset = 1;

	/*
	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
	 * string begins with a '+'.
	 */
	if (posixly_correct == -1 || optreset)
		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
	if (*options == '-')
		flags |= FLAG_ALLARGS;
	else if (posixly_correct || *options == '+')
		flags &= ~FLAG_PERMUTE;
	if (*options == '+' || *options == '-')
		options++;

	optarg = NULL;
	if (optreset)
		nonopt_start = nonopt_end = -1;
start:
	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc) {          /* end of argument vector */
			place = EMSG;
			if (nonopt_end != -1) {
				/* do permutation, if we have to */
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			else if (nonopt_start != -1) {
				/*
				 * If we skipped non-options, set optind
				 * to the first of them.
				 */
				optind = nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
		if (*(place = nargv[optind]) != '-' ||
#ifdef GNU_COMPATIBLE
		    place[1] == '\0') {
#else
		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
#endif
			place = EMSG;		/* found non-option */
			if (flags & FLAG_ALLARGS) {
				/*
				 * GNU extension:
				 * return non-option as argument to option 1
				 */
				optarg = nargv[optind++];
				return (INORDER);
			}
			if (!(flags & FLAG_PERMUTE)) {
				/*
				 * If no permutation wanted, stop parsing
				 * at first non-option.
				 */
				return (-1);
			}
			/* do permutation */
			if (nonopt_start == -1)
				nonopt_start = optind;
			else if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				nonopt_start = optind -
				    (nonopt_end - nonopt_start);
				nonopt_end = -1;
			}
			optind++;
			/* process next argument */
			goto start;
		}
		if (nonopt_start != -1 && nonopt_end == -1)
			nonopt_end = optind;

		/*
		 * If we have "-" do nothing, if "--" we are done.
		 */
		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
			optind++;
			place = EMSG;
			/*
			 * We found an option (--), so if we skipped
			 * non-options, we have to permute.
			 */
			if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
	}

	/*
	 * Check long options if:
	 *  1) we were passed some
	 *  2) the arg is not just "-"
	 *  3) either the arg starts with -- we are getopt_long_only()
	 */
	if (long_options != NULL && place != nargv[optind] &&
	    (*place == '-' || (flags & FLAG_LONGONLY))) {
		short_too = 0;
#ifdef GNU_COMPATIBLE
		dash_prefix = D_PREFIX;
#endif
		if (*place == '-') {
			place++;		/* --foo long option */
#ifdef GNU_COMPATIBLE
			dash_prefix = DD_PREFIX;
#endif
		} else if (*place != ':' && strchr(options, *place) != NULL)
			short_too = 1;		/* could be short option too */

		optchar = parse_long_options(nargv, options, long_options,
		    idx, short_too, flags);
		if (optchar != -1) {
			place = EMSG;
			return (optchar);
		}
	}

	if ((optchar = (int)*place++) == (int)':' ||
	    (optchar == (int)'-' && *place != '\0') ||
	    (oli = strchr(options, optchar)) == NULL) {
		/*
		 * If the user specified "-" and  '-' isn't listed in
		 * options, return -1 (non-option) as per POSIX.
		 * Otherwise, it is an unknown option character (or ':').
		 */
		if (optchar == (int)'-' && *place == '\0')
			return (-1);
		if (!*place)
			++optind;
#ifdef GNU_COMPATIBLE
		if (PRINT_ERROR)
			warnx(posixly_correct ? illoptchar : gnuoptchar,
			      optchar);
#else
		if (PRINT_ERROR)
			warnx(illoptchar, optchar);
#endif
		optopt = optchar;
		return (BADCH);
	}
	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
		/* -W long-option */
		if (*place)			/* no space */
			/* NOTHING */;
		else if (++optind >= nargc) {	/* no arg */
			place = EMSG;
			if (PRINT_ERROR)
				warnx(recargchar, optchar);
			optopt = optchar;
			return (BADARG);
		} else				/* white space */
			place = nargv[optind];
#ifdef GNU_COMPATIBLE
		dash_prefix = W_PREFIX;
#endif
		optchar = parse_long_options(nargv, options, long_options,
		    idx, 0, flags);
		place = EMSG;
		return (optchar);
	}
	if (*++oli != ':') {			/* doesn't take argument */
		if (!*place)
			++optind;
	} else {				/* takes (optional) argument */
		optarg = NULL;
		if (*place)			/* no white space */
			optarg = place;
		else if (oli[1] != ':') {	/* arg not optional */
			if (++optind >= nargc) {	/* no arg */
				place = EMSG;
				if (PRINT_ERROR)
					warnx(recargchar, optchar);
				optopt = optchar;
				return (BADARG);
			} else
				optarg = nargv[optind];
		}
		place = EMSG;
		++optind;
	}
	/* dump back option letter */
	return (optchar);
}

#ifdef REPLACE_GETOPT
/*
 * getopt --
 *	Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int
getopt(int nargc, char * const *nargv, const char *options)
{

	/*
	 * We don't pass FLAG_PERMUTE to getopt_internal() since
	 * the BSD getopt(3) (unlike GNU) has never done this.
	 *
	 * Furthermore, since many privileged programs call getopt()
	 * before dropping privileges it makes sense to keep things
	 * as simple (and bug-free) as possible.
	 */
	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}
#endif /* REPLACE_GETOPT */

/*
 * getopt_long --
 *	Parse argc/argv argument vector.
 */
int
getopt_long(int nargc, char * const *nargv, const char *options,
	const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *	Parse argc/argv argument vector.
 */
int
getopt_long_only(int nargc, char * const *nargv, const char *options,
	const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE|FLAG_LONGONLY));
}

/* *******  End of drop-in of getopt_long() from FreeBSD source ******* */
/* ******************************************************************** */

/*  end of code Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
    and derived from code Copyright (c) 2000 The NetBSD Foundation, Inc.
    Used in accordance with the license reproduced at the beginning
    of getopt_long(), above.

*/

/* ************ end of content subject to getopt copyright ************ */
/* ******************************************************************** */

#endif